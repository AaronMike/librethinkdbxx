// auto-generated by yaml_to_cxx.py from test/upstream/transformation.yaml
#include "testlib.h"
void test_upstream_transformation() {
    enter_section("test_upstream_transformation: Tests that manipulation data in tables");
    temp_table tbl_table;
    R::Query tbl = tbl_table.table();
    temp_table tbl2_table;
    R::Query tbl2 = tbl2_table.table();
    temp_table tbl3_table;
    R::Query tbl3 = tbl3_table.table();
    TEST_EQ(maybe_run(tbl.insert(R::range(100).map([=](R::Var i){ return R::object("id", *i, "a", *i % 4); })), *conn), (R::Object{{"deleted", 0.0}, {"replaced", 0.0}, {"unchanged", 0.0}, {"errors", 0.0}, {"skipped", 0.0}, {"inserted", 100}}));
    TEST_EQ(maybe_run(tbl.index_create("a"), *conn), (R::Object{{"created", 1}}));
    TEST_EQ(maybe_run(tbl.index_create("truncated_a", [=](R::Var x){ return R::array(repeat("a", 300), (*x)["a"]); }), *conn), (R::Object{{"created", 1}}));
    TEST_EQ(maybe_run(tbl.index_create("error_prone", [=](R::Var x){ return R::expr(1) / (*x)["a"]; }), *conn), (R::Object{{"created", 1}}));
    TEST_DO(maybe_run(tbl.index_wait().pluck("index", "ready"), *conn));
    TEST_EQ(maybe_run(tbl2.insert(R::range(100).map([=](R::Var i){ return R::object("id", *i, "b", *i % 4); })), *conn), (R::Object{{"deleted", 0.0}, {"replaced", 0.0}, {"unchanged", 0.0}, {"errors", 0.0}, {"skipped", 0.0}, {"inserted", 100}}));
    TEST_EQ(maybe_run(tbl3.insert(R::range(100).map([=](R::Var i){ return R::object("id", *i, "a", *i % 4, "b", R::object("c", *i % 5)); })), *conn), (R::Object{{"deleted", 0.0}, {"replaced", 0.0}, {"unchanged", 0.0}, {"errors", 0.0}, {"skipped", 0.0}, {"inserted", 100}}));
    TEST_EQ(maybe_run(tbl.map([=](R::Var row){ return (*row)["id"]; }).reduce([=](R::Var a, R::Var b){ return *a + *b; }), *conn), (4950));
    TEST_EQ(maybe_run(tbl.map(R::row["id"]).reduce([=](R::Var a, R::Var b){ return *a + *b; }), *conn), (4950));
    TEST_EQ(maybe_run(tbl.union_(tbl).map([=](R::Var row){ return (*row)["id"]; }).reduce([=](R::Var a, R::Var b){ return *a + *b; }), *conn), (9900));
    TEST_EQ(maybe_run(tbl.union_(tbl).map(R::row["id"]).reduce([=](R::Var a, R::Var b){ return *a + *b; }), *conn), (9900));
    TEST_EQ(maybe_run(tbl.coerce_to("array").union_(tbl).map([=](R::Var row){ return (*row)["id"]; }).reduce([=](R::Var a, R::Var b){ return *a + *b; }), *conn), (9900));
    TEST_EQ(maybe_run(tbl.coerce_to("array").union_(tbl).map(R::row["id"]).reduce([=](R::Var a, R::Var b){ return *a + *b; }), *conn), (9900));
    TEST_EQ(maybe_run(tbl.union_(tbl.coerce_to("array")).map([=](R::Var row){ return (*row)["id"]; }).reduce([=](R::Var a, R::Var b){ return *a + *b; }), *conn), (9900));
    TEST_EQ(maybe_run(tbl.union_(tbl.coerce_to("array")).map(R::row["id"]).reduce([=](R::Var a, R::Var b){ return *a + *b; }), *conn), (9900));
    TEST_EQ(maybe_run(tbl.get_all().fold(0, [=](R::Var acc, R::Var _){ return (*acc).add(1); }, R::OptArgs{{"emit", R::expr([=](R::Var old, R::Var row, R::Var acc){ return R::array(*acc); })}}), *conn), (R::Array{}));
    TEST_EQ(maybe_run(R::range(0, 10).fold(0, [=](R::Var acc, R::Var _){ return (*acc).add(1); }, R::OptArgs{{"emit", R::expr([=](R::Var old, R::Var row, R::Var acc){ return *acc; })}}), *conn), (err("ReqlQueryLogicError", "Expected type ARRAY but found NUMBER.")));
    TEST_EQ(maybe_run(R::range(0, 10).fold(0, [=](R::Var acc, R::Var _){ return (*acc).add(1); }, R::OptArgs{{"emit", R::expr([=](R::Var old, R::Var row, R::Var acc){ return R::range(); })}}), *conn), (err("ReqlQueryLogicError", "Expected type DATUM but found SEQUENCE:")));
    TEST_EQ(maybe_run(R::range(0, 10).fold(0, [=](R::Var acc, R::Var _){ return (*acc).add(1); }, R::OptArgs{{"emit", R::expr([=](R::Var old, R::Var row, R::Var acc){ return R::array(*acc); })}}).changes(), *conn), (err("ReqlQueryLogicError", "Cannot call `changes` on an eager stream.")));
    TEST_EQ(maybe_run(tbl.concat_map([=](R::Var row){ return R::array(); }), *conn), (R::Array{}));
    TEST_DO(auto ccm = (tbl.concat_map([=](R::Var row){ return R::array((*row)["a"], ((*row)["a"] + 1) % 4); })));
    TEST_EQ(maybe_run(ccm.count(), *conn), (200));
    TEST_EQ(maybe_run(ccm.reduce([=](R::Var a, R::Var b){ return (*a + *b) % 4; }), *conn), (0));
    TEST_EQ(maybe_run(tbl.order_by("id")[0], *conn), (R::Object{{"id", 0}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl.order_by(R::array(1, 2, 3)), *conn), (err("ReqlQueryLogicError", "Expected type STRING but found ARRAY.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.order_by(R::OptArgs{{"index", R::expr("id")}})[0], *conn), (R::Object{{"id", 0}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl.order_by(R::OptArgs{{"index", R::expr("id")}})[0].update(R::object("a", 0))["unchanged"], *conn), (1));
    TEST_EQ(maybe_run(tbl.get_all(0).update(R::object("a", 0))["unchanged"], *conn), (1));
    TEST_EQ(maybe_run(tbl.order_by(R::OptArgs{{"index", R::expr("id")}}).order_by(R::OptArgs{{"index", R::expr("id")}})[0], *conn), (err("ReqlQueryLogicError", "Cannot perform multiple indexed ORDER_BYs on the same table.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.order_by(R::OptArgs{{"index", R::expr("id")}}).order_by(R::OptArgs{{"index", R::expr("id")}})[0], *conn), (err("ReqlQueryLogicError", "Cannot perform multiple indexed ORDER_BYs on the same table.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.order_by("id").order_by(R::OptArgs{{"index", R::expr("id")}})[0], *conn), (err("ReqlQueryLogicError", "Indexed order_by can only be performed on a TABLE or TABLE_SLICE.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.order_by("id").order_by(R::OptArgs{{"index", R::expr("a")}})[0], *conn), (err("ReqlQueryLogicError", "Indexed order_by can only be performed on a TABLE or TABLE_SLICE.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.between(5, R::maxval, R::OptArgs{{"index", R::expr("id")}}).order_by(R::OptArgs{{"index", R::expr("id")}})[0], *conn), (R::Object{{"id", 5}, {"a", 1}}));
    TEST_EQ(maybe_run(tbl.order_by("a", R::OptArgs{{"index", R::expr("id")}}).between(5, R::maxval, R::OptArgs{{"index", R::expr("id")}})[0], *conn), (err("ReqlQueryLogicError", "Expected type TABLE_SLICE but found SELECTION:", R::Array{0})));
    TEST_EQ(maybe_run(tbl.order_by([=](R::Var x){ return (*x)["id"]; })[0], *conn), (R::Object{{"id", 0}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl.order_by("a", "id").nth(0), *conn), (R::Object{{"id", 0}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl.order_by("id", R::OptArgs{{"index", R::expr("a")}}).nth(0), *conn), (R::Object{{"id", 0}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl.order_by("id", R::OptArgs{{"index", R::expr("truncated_a")}}).nth(0), *conn), (R::Object{{"id", 0}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl.order_by("id", R::OptArgs{{"index", R::expr("error_prone")}}).nth(0), *conn), (R::Object{{"id", 3}, {"a", 3}}));
    TEST_EQ(maybe_run(tbl.order_by([=](R::Var x){ return R::array((*x)["a"], (*x)["id"]); })[0], *conn), (R::Object{{"id", 0}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl.order_by(R::desc("a"), R::asc("id")).nth(0), *conn), (R::Object{{"id", 3}, {"a", 3}}));
    TEST_EQ(maybe_run(tbl.order_by("id", R::OptArgs{{"index", R::expr(R::desc("a"))}}).nth(0), *conn), (R::Object{{"id", 3}, {"a", 3}}));
    TEST_EQ(maybe_run(tbl.order_by(R::desc([=](R::Var x){ return (*x)["a"]; }), [=](R::Var x){ return (*x)["id"]; })[0], *conn), (R::Object{{"id", 3}, {"a", 3}}));
    TEST_EQ(maybe_run(tbl.order_by(R::asc("a"), R::desc("id")).nth(0), *conn), (R::Object{{"id", 96}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl.order_by(R::desc("id"), R::OptArgs{{"index", R::expr("a")}}).nth(0), *conn), (R::Object{{"id", 96}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl.order_by("id").type_of(), *conn), ("SELECTION<ARRAY>"));
    TEST_EQ(maybe_run(tbl.order_by("missing").order_by("id").nth(0), *conn), (R::Object{{"id", 0}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl.order_by("missing").order_by(R::OptArgs{{"index", R::expr("id")}}).nth(0), *conn), (err("ReqlQueryLogicError", "Indexed order_by can only be performed on a TABLE or TABLE_SLICE.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.order_by("id", "missing").nth(0), *conn), (R::Object{{"id", 0}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl.order_by("missing", R::OptArgs{{"index", R::expr("id")}}).nth(0), *conn), (R::Object{{"id", 0}, {"a", 0}}));
    TEST_EQ(maybe_run((tbl.order_by(R::desc("id")).coerce_to("ARRAY")==tbl.order_by([=](R::Var x){ return R::expr(0) - (*x)["id"]; }).coerce_to("ARRAY")), *conn), (true));
    TEST_EQ(maybe_run((tbl.order_by(R::OptArgs{{"index", R::expr(R::desc("id"))}}).coerce_to("ARRAY")==tbl.order_by([=](R::Var x){ return R::expr(0) - (*x)["id"]; }).coerce_to("ARRAY")), *conn), (true));
    TEST_EQ(maybe_run((tbl.order_by(R::OptArgs{{"index", R::expr(R::desc("id"))}}).coerce_to("ARRAY")==tbl.order_by(R::desc("id")).coerce_to("ARRAY")), *conn), (true));
    TEST_EQ(maybe_run(tbl.skip(1).count(), *conn), (99));
    TEST_EQ(maybe_run(tbl.skip(-1).count(), *conn), (err("ReqlQueryLogicError", "Cannot use a negative left index on a stream.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.skip("foo").count(), *conn), (err("ReqlQueryLogicError", "Expected type NUMBER but found STRING.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.limit(1).count(), *conn), (1));
    TEST_EQ(maybe_run(tbl.limit(-1).count(), *conn), (err("ReqlQueryLogicError", "LIMIT takes a non-negative argument (got -1)", R::Array{0})));
    TEST_EQ(maybe_run(tbl.limit("foo").count(), *conn), (err("ReqlQueryLogicError", "Expected type NUMBER but found STRING.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.slice(1, 3).count(), *conn), (2));
    TEST_EQ(maybe_run(tbl.slice(5).count(), *conn), (95));
    TEST_EQ(maybe_run(tbl.slice(-1, -3).count(), *conn), (err("ReqlQueryLogicError", "Cannot use a negative left index on a stream.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.slice(0, -3).count(), *conn), (err("ReqlQueryLogicError", "Cannot use a right index < -1 on a stream.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.slice(0, -1).count(), *conn), (err("ReqlQueryLogicError", "Cannot slice to an open right index of -1 on a stream.", R::Array{})));
    TEST_EQ(maybe_run(tbl.slice("foo", "bar").count(), *conn), (err("ReqlQueryLogicError", "Expected type NUMBER but found STRING.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.slice(1, R::Nil()).count(), *conn), (err("ReqlNonExistenceError", "Expected type NUMBER but found NULL.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.slice(R::Nil(), 1).count(), *conn), (err("ReqlNonExistenceError", "Expected type NUMBER but found NULL.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.slice(12, 20).count(), *conn), (8));
    TEST_EQ(maybe_run(tbl.slice(12, 20, R::OptArgs{{"right_bound", R::expr("closed")}}).count(), *conn), (9));
    TEST_EQ(maybe_run(tbl.slice(12, 20, R::OptArgs{{"left_bound", R::expr("open")}}).count(), *conn), (7));
    TEST_EQ(maybe_run(tbl.slice(12, 20, R::OptArgs{{"left_bound", R::expr("open")}, {"right_bound", R::expr("closed")}}).count(), *conn), (8));
    TEST_EQ(maybe_run(tbl.slice(12, -1).count(), *conn), (err("ReqlQueryLogicError", "Cannot slice to an open right index of -1 on a stream.", R::Array{})));
    TEST_EQ(maybe_run(tbl.slice(12, -1, R::OptArgs{{"right_bound", R::expr("closed")}}).count(), *conn), (88));
    TEST_EQ(maybe_run(tbl.slice(12, -2).count(), *conn), (err("ReqlQueryLogicError", "Cannot use a right index < -1 on a stream.", R::Array{})));
    TEST_EQ(maybe_run(tbl.slice(12, -2, R::OptArgs{{"right_bound", R::expr("closed")}}).count(), *conn), (err("ReqlQueryLogicError", "Cannot use a right index < -1 on a stream.", R::Array{})));
    TEST_EQ(maybe_run(tbl.slice(-12, -2).count(), *conn), (err("ReqlQueryLogicError", "Cannot use a negative left index on a stream.", R::Array{})));
    TEST_EQ(maybe_run(tbl.slice(-12, -2, R::OptArgs{{"right_bound", R::expr("closed")}}).count(), *conn), (err("ReqlQueryLogicError", "Cannot use a negative left index on a stream.", R::Array{})));
    TEST_EQ(maybe_run(tbl.coerce_to("array").slice(12, 20).count(), *conn), (8));
    TEST_EQ(maybe_run(tbl.coerce_to("array").slice(12, 20, R::OptArgs{{"right_bound", R::expr("closed")}}).count(), *conn), (9));
    TEST_EQ(maybe_run(tbl.coerce_to("array").slice(12, 20, R::OptArgs{{"left_bound", R::expr("open")}}).count(), *conn), (7));
    TEST_EQ(maybe_run(tbl.coerce_to("array").slice(12, 20, R::OptArgs{{"left_bound", R::expr("open")}, {"right_bound", R::expr("closed")}}).count(), *conn), (8));
    TEST_EQ(maybe_run(tbl.coerce_to("array").slice(12, -1).count(), *conn), (87));
    TEST_EQ(maybe_run(tbl.coerce_to("array").slice(12, -1, R::OptArgs{{"right_bound", R::expr("closed")}}).count(), *conn), (88));
    TEST_EQ(maybe_run(tbl.coerce_to("array").slice(12, -2).count(), *conn), (86));
    TEST_EQ(maybe_run(tbl.coerce_to("array").slice(12, -2, R::OptArgs{{"right_bound", R::expr("closed")}}).count(), *conn), (87));
    TEST_EQ(maybe_run(tbl.coerce_to("array").slice(-12, -2).count(), *conn), (10));
    TEST_EQ(maybe_run(tbl.coerce_to("array").slice(-12, -2, R::OptArgs{{"right_bound", R::expr("closed")}}).count(), *conn), (11));
    TEST_DO(auto arr = (R::expr(R::array(1, 2, 3, 4, 5))));
    TEST_EQ(maybe_run(arr.slice(1, 3), *conn), (R::Array{2, 3}));
    TEST_EQ(maybe_run(arr.slice(1, -3), *conn), (R::Array{2}));
    TEST_EQ(maybe_run(arr.slice(1), *conn), (R::Array{2, 3, 4, 5}));
    TEST_EQ(maybe_run(arr.slice(1, -1), *conn), (R::Array{2, 3, 4}));
    TEST_EQ(maybe_run(tbl.order_by("id").nth(1), *conn), (R::Object{{"id", 1}, {"a", 1}}));
    TEST_EQ(maybe_run(tbl.order_by("id").nth(-1), *conn), (R::Object{{"id", 99}, {"a", 3}}));
    TEST_EQ(maybe_run(tbl.order_by("id").nth("foo").count(), *conn), (err("ReqlQueryLogicError", "Expected type NUMBER but found STRING.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.is_empty(), *conn), (false));
    TEST_EQ(maybe_run(tbl.limit(0).is_empty(), *conn), (true));
    TEST_EQ(maybe_run(R::expr(1).is_empty(), *conn), (err("ReqlQueryLogicError", "Cannot convert NUMBER to SEQUENCE", R::Array{})));
    TEST_EQ(maybe_run(R::expr("").is_empty(), *conn), (err("ReqlQueryLogicError", "Cannot convert STRING to SEQUENCE", R::Array{})));
    TEST_EQ(maybe_run(tbl3.pluck().nth(0), *conn), (R::Object{}));
    TEST_EQ(maybe_run(tbl3.pluck(R::object()).nth(0), *conn), (R::Object{}));
    TEST_EQ(maybe_run(tbl3.pluck(R::array()).nth(0), *conn), (R::Object{}));
    TEST_EQ(maybe_run(tbl3.pluck("id").order_by("id").nth(0), *conn), (R::Object{{"id", 0}}));
    TEST_EQ(maybe_run(tbl3.pluck(R::array("id")).order_by("id").nth(0), *conn), (R::Object{{"id", 0}}));
    TEST_EQ(maybe_run(tbl3.pluck(R::object("id", true)).order_by("id").nth(0), *conn), (R::Object{{"id", 0}}));
    TEST_EQ(maybe_run(tbl3.pluck("id", "a").order_by("id").nth(0), *conn), (R::Object{{"id", 0}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl3.pluck(R::array("id", "a")).order_by("id").nth(0), *conn), (R::Object{{"id", 0}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl3.pluck(R::object("id", true, "a", true)).order_by("id").nth(0), *conn), (R::Object{{"id", 0}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl3.pluck("id", "missing").order_by("id").nth(0), *conn), (R::Object{{"id", 0}}));
    TEST_EQ(maybe_run(tbl3.pluck(R::array("id", "missing")).order_by("id").nth(0), *conn), (R::Object{{"id", 0}}));
    TEST_EQ(maybe_run(tbl3.pluck(R::object("id", true, "missing", true)).order_by("id").nth(0), *conn), (R::Object{{"id", 0}}));
    TEST_EQ(maybe_run(tbl3.pluck("id", R::object("b", "c")).order_by("id").nth(0), *conn), (R::Object{{"id", 0}, {"b", R::Object{{"c", 0}}}}));
    TEST_EQ(maybe_run(tbl3.pluck(R::array("id", R::object("b", "c"))).order_by("id").nth(0), *conn), (R::Object{{"id", 0}, {"b", R::Object{{"c", 0}}}}));
    TEST_EQ(maybe_run(tbl3.pluck(1), *conn), (err("ReqlQueryLogicError", "Invalid path argument `1`.", R::Array{})));
    TEST_EQ(maybe_run(R::expr(R::array(R::array(R::object("foo", 1)))).pluck("foo"), *conn), (err("ReqlQueryLogicError", "Cannot perform pluck on a sequence of sequences.", R::Array{})));
    TEST_EQ(maybe_run(R::expr(R::array("a", "b")).map([=](R::Var x){ return R::expr(R::object("a", 1, "b", 2)).pluck(*x); }), *conn), (R::Array{R::Object{{"a", 1}}, R::Object{{"b", 2}}}));
    TEST_EQ(maybe_run(R::expr(R::object("foo", R::object("bar", 1))).pluck(R::object("foo", R::object("bar", "buzz"))), *conn), (R::Object{{"foo", R::Object{}}}));
    TEST_EQ(maybe_run(tbl.without().order_by("id").nth(0), *conn), (R::Object{{"id", 0}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl.without("a").order_by("id").nth(0), *conn), (R::Object{{"id", 0}}));
    TEST_EQ(maybe_run(tbl.without("id", "a").nth(0), *conn), (R::Object{}));
    TEST_EQ(maybe_run(tbl.without("a", "missing").order_by("id").nth(0), *conn), (R::Object{{"id", 0}}));
    TEST_EQ(maybe_run(tbl3.without("a", R::object("b", "c")).order_by("id").nth(0), *conn), (R::Object{{"id", 0}, {"b", R::Object{}}}));
    TEST_EQ(maybe_run(tbl3.without(R::array("a", R::object("b", "c"))).order_by("id").nth(0), *conn), (R::Object{{"id", 0}, {"b", R::Object{}}}));
    TEST_EQ(maybe_run(tbl3.without(R::array("a", R::object("b", "d"))).order_by("id").nth(0), *conn), (R::Object{{"id", 0}, {"b", R::Object{{"c", 0}}}}));
    TEST_EQ(maybe_run(tbl.union_(tbl2).count(), *conn), (200));
    TEST_EQ(maybe_run(tbl.union_(R::array(1, 2, 3)).count(), *conn), (103));
    TEST_EQ(maybe_run(R::expr(R::array(1, 2, 3)).union_(tbl2).count(), *conn), (103));
    TEST_DO(auto ord = (tbl.order_by(std::string("id", 2))));
    TEST_EQ(maybe_run(ord.offsets_of(R::row["id"]<2), *conn), (R::Array{0, 1}));
    TEST_EQ(maybe_run(R::expr(R::array(1, 2, 3, 4)).offsets_of(3), *conn), (R::Array{2}));
    TEST_EQ(maybe_run(R::expr(R::array(1)).offsets_of(tbl), *conn), (err("ReqlQueryLogicError", "Expected type DATUM but found TABLE:", R::Array{})));
    TEST_EQ(maybe_run(R::expr(1).do_([=](R::Var x){ return R::expr(R::array(2, 1, 0)).offsets_of(*x); }), *conn), (R::Array{1}));
    TEST_EQ(maybe_run(tbl.contains(tbl[0]), *conn), (true));
    TEST_EQ(maybe_run(tbl.contains(tbl[0].pluck("id")), *conn), (false));
    TEST_EQ(maybe_run(tbl3.filter(R::object("b", R::object("c", 0))).pluck("id").order_by("id").nth(0), *conn), (R::Object{{"id", 0}}));
    TEST_EQ(maybe_run(tbl3.filter(R::object("b", R::object("c", 6))), *conn), (R::Array{}));
    TEST_EQ(maybe_run(tbl3.filter(R::literal(R::object("id", 0))), *conn), (R::Array{}));
    TEST_EQ(maybe_run(tbl3.filter(R::object("b", R::literal(R::object("c", 0)))).pluck("id").order_by("id").nth(0), *conn), (R::Object{{"id", 0}}));
    exit_section();
}
