// auto-generated by yaml_to_cxx.py from test/upstream/transformation.yaml
#include "testlib.h"
void test_upstream_transformation() {
    enter_section("test_upstream_transformation: Tests that manipulation data in tables");
    temp_table tbl_table;
    R::Query tbl = tbl_table.table();
    TEST_DO(auto tbl2 = (R::db("test").table("test2")));
    TEST_DO(auto tbl3 = (R::db("test").table("test3")));
    TEST_EQ(tbl.insert(R::range(100).map([=](R::Var i){ return R::object("id", *i, "a", *i % 4); })).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",0.0}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",100}}));
    TEST_EQ(tbl.index_create("a").run(*conn), (R::Object{{"created",1}}));
    TEST_EQ(tbl.index_create("truncated_a", [=](R::Var x){ return R::array(repeat("a", 300), (*x)["a"]); }).run(*conn), (R::Object{{"created",1}}));
    TEST_EQ(tbl.index_create("error_prone", [=](R::Var x){ return R::expr(1) / (*x)["a"]; }).run(*conn), (R::Object{{"created",1}}));
    tbl.index_wait().pluck("index", "ready").run(*conn);
    TEST_EQ(tbl2.insert(R::range(100).map([=](R::Var i){ return R::object("id", *i, "b", *i % 4); })).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",0.0}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",100}}));
    TEST_EQ(tbl3.insert(R::range(100).map([=](R::Var i){ return R::object("id", *i, "a", *i % 4, "b", R::object("c", *i % 5)); })).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",0.0}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",100}}));
    TEST_EQ(tbl.map([=](R::Var row){ return (*row)["id"]; }).reduce([=](R::Var a, R::Var b){ return *a + *b; }).run(*conn), (4950));
    TEST_EQ(tbl.map(R::row["id"]).reduce([=](R::Var a, R::Var b){ return *a + *b; }).run(*conn), (4950));
    TEST_EQ(tbl.union_(tbl).map([=](R::Var row){ return (*row)["id"]; }).reduce([=](R::Var a, R::Var b){ return *a + *b; }).run(*conn), (9900));
    TEST_EQ(tbl.union_(tbl).map(R::row["id"]).reduce([=](R::Var a, R::Var b){ return *a + *b; }).run(*conn), (9900));
    TEST_EQ(tbl.coerce_to("array").union_(tbl).map([=](R::Var row){ return (*row)["id"]; }).reduce([=](R::Var a, R::Var b){ return *a + *b; }).run(*conn), (9900));
    TEST_EQ(tbl.coerce_to("array").union_(tbl).map(R::row["id"]).reduce([=](R::Var a, R::Var b){ return *a + *b; }).run(*conn), (9900));
    TEST_EQ(tbl.union_(tbl.coerce_to("array")).map([=](R::Var row){ return (*row)["id"]; }).reduce([=](R::Var a, R::Var b){ return *a + *b; }).run(*conn), (9900));
    TEST_EQ(tbl.union_(tbl.coerce_to("array")).map(R::row["id"]).reduce([=](R::Var a, R::Var b){ return *a + *b; }).run(*conn), (9900));
    TEST_EQ(tbl.concat_map([=](R::Var row){ return R::array(); }).run(*conn), (R::Array{}));
    TEST_DO(auto ccm = (tbl.concat_map([=](R::Var row){ return R::array((*row)["a"], ((*row)["a"] + 1) % 4); })));
    TEST_EQ(ccm.count().run(*conn), (200));
    TEST_EQ(ccm.reduce([=](R::Var a, R::Var b){ return (*a + *b) % 4; }).run(*conn), (0));
    TEST_EQ(tbl.order_by("id")[0].run(*conn), (R::Object{{"id",0}, {"a",0}}));
    TEST_EQ(tbl.order_by(R::array(1, 2, 3)).run(*conn), (err("RqlRuntimeError", "Expected type STRING but found ARRAY.", R::Array{0})));
    TEST_EQ(tbl.order_by(R::OptArgs{{"index", R::expr("id")}})[0].run(*conn), (R::Object{{"id",0}, {"a",0}}));
    TEST_EQ(tbl.order_by(R::OptArgs{{"index", R::expr("id")}})[0].update(R::object("a", 0))["unchanged"].run(*conn), (1));
    TEST_EQ(tbl.get_all(0).update(R::object("a", 0))["unchanged"].run(*conn), (1));
    TEST_EQ(tbl.order_by(R::OptArgs{{"index", R::expr("id")}}).order_by(R::OptArgs{{"index", R::expr("id")}})[0].run(*conn), (err("RqlRuntimeError", "Cannot perform multiple indexed ORDER_BYs on the same table.", R::Array{0})));
    TEST_EQ(tbl.order_by(R::OptArgs{{"index", R::expr("id")}}).order_by(R::OptArgs{{"index", R::expr("id")}})[0].run(*conn), (err("RqlRuntimeError", "Cannot perform multiple indexed ORDER_BYs on the same table.", R::Array{0})));
    TEST_EQ(tbl.order_by("id").order_by(R::OptArgs{{"index", R::expr("id")}})[0].run(*conn), (err("RqlRuntimeError", "Indexed order_by can only be performed on a TABLE or TABLE_SLICE.", R::Array{0})));
    TEST_EQ(tbl.order_by("id").order_by(R::OptArgs{{"index", R::expr("a")}})[0].run(*conn), (err("RqlRuntimeError", "Indexed order_by can only be performed on a TABLE or TABLE_SLICE.", R::Array{0})));
    TEST_EQ(tbl.between(5, R::maxval, R::OptArgs{{"index", R::expr("id")}}).order_by(R::OptArgs{{"index", R::expr("id")}})[0].run(*conn), (R::Object{{"id",5}, {"a",1}}));
    TEST_EQ(tbl.order_by("a", R::OptArgs{{"index", R::expr("id")}}).between(5, R::maxval, R::OptArgs{{"index", R::expr("id")}})[0].run(*conn), (err("RqlRuntimeError", "Expected type TABLE_SLICE but found SELECTION.", R::Array{0})));
    TEST_EQ(tbl.order_by([=](R::Var x){ return (*x)["id"]; })[0].run(*conn), (R::Object{{"id",0}, {"a",0}}));
    TEST_EQ(tbl.order_by("a", "id").nth(0).run(*conn), (R::Object{{"id",0}, {"a",0}}));
    TEST_EQ(tbl.order_by("id", R::OptArgs{{"index", R::expr("a")}}).nth(0).run(*conn), (R::Object{{"id",0}, {"a",0}}));
    TEST_EQ(tbl.order_by("id", R::OptArgs{{"index", R::expr("truncated_a")}}).nth(0).run(*conn), (R::Object{{"id",0}, {"a",0}}));
    TEST_EQ(tbl.order_by("id", R::OptArgs{{"index", R::expr("error_prone")}}).nth(0).run(*conn), (R::Object{{"id",3}, {"a",3}}));
    TEST_EQ(tbl.order_by([=](R::Var x){ return R::array((*x)["a"], (*x)["id"]); })[0].run(*conn), (R::Object{{"id",0}, {"a",0}}));
    TEST_EQ(tbl.order_by(R::desc("a"), R::asc("id")).nth(0).run(*conn), (R::Object{{"id",3}, {"a",3}}));
    TEST_EQ(tbl.order_by("id", R::OptArgs{{"index", R::expr(R::desc("a"))}}).nth(0).run(*conn), (R::Object{{"id",3}, {"a",3}}));
    TEST_EQ(tbl.order_by(R::desc([=](R::Var x){ return (*x)["a"]; }), [=](R::Var x){ return (*x)["id"]; })[0].run(*conn), (R::Object{{"id",3}, {"a",3}}));
    TEST_EQ(tbl.order_by(R::asc("a"), R::desc("id")).nth(0).run(*conn), (R::Object{{"id",96}, {"a",0}}));
    TEST_EQ(tbl.order_by(R::desc("id"), R::OptArgs{{"index", R::expr("a")}}).nth(0).run(*conn), (R::Object{{"id",96}, {"a",0}}));
    TEST_EQ(tbl.order_by("id").type_of().run(*conn), ("SELECTION<ARRAY>"));
    TEST_EQ(tbl.order_by("missing").order_by("id").nth(0).run(*conn), (R::Object{{"id",0}, {"a",0}}));
    TEST_EQ(tbl.order_by("missing").order_by(R::OptArgs{{"index", R::expr("id")}}).nth(0).run(*conn), (err("RqlRuntimeError", "Indexed order_by can only be performed on a TABLE or TABLE_SLICE.", R::Array{0})));
    TEST_EQ(tbl.order_by("id", "missing").nth(0).run(*conn), (R::Object{{"id",0}, {"a",0}}));
    TEST_EQ(tbl.order_by("missing", R::OptArgs{{"index", R::expr("id")}}).nth(0).run(*conn), (R::Object{{"id",0}, {"a",0}}));
    TEST_EQ((tbl.order_by(R::desc("id")).coerce_to("ARRAY")==tbl.order_by([=](R::Var x){ return R::expr(0) - (*x)["id"]; }).coerce_to("ARRAY")).run(*conn), (true));
    TEST_EQ((tbl.order_by(R::OptArgs{{"index", R::expr(R::desc("id"))}}).coerce_to("ARRAY")==tbl.order_by([=](R::Var x){ return R::expr(0) - (*x)["id"]; }).coerce_to("ARRAY")).run(*conn), (true));
    TEST_EQ((tbl.order_by(R::OptArgs{{"index", R::expr(R::desc("id"))}}).coerce_to("ARRAY")==tbl.order_by(R::desc("id")).coerce_to("ARRAY")).run(*conn), (true));
    TEST_EQ(tbl.skip(1).count().run(*conn), (99));
    TEST_EQ(tbl.skip(-1).count().run(*conn), (err("RqlRuntimeError", "Cannot use a negative left index on a stream.", R::Array{0})));
    TEST_EQ(tbl.skip("foo").count().run(*conn), (err("RqlRuntimeError", "Expected type NUMBER but found STRING.", R::Array{0})));
    TEST_EQ(tbl.limit(1).count().run(*conn), (1));
    TEST_EQ(tbl.limit(-1).count().run(*conn), (err("RqlRuntimeError", "LIMIT takes a non-negative argument (got -1)", R::Array{0})));
    TEST_EQ(tbl.limit("foo").count().run(*conn), (err("RqlRuntimeError", "Expected type NUMBER but found STRING.", R::Array{0})));
    TEST_EQ(tbl.slice(1, 3).count().run(*conn), (2));
    TEST_EQ(tbl.slice(5).count().run(*conn), (95));
    TEST_EQ(tbl.slice(-1, -3).count().run(*conn), (err("RqlRuntimeError", "Cannot use a negative left index on a stream.", R::Array{0})));
    TEST_EQ(tbl.slice(0, -3).count().run(*conn), (err("RqlRuntimeError", "Cannot use a right index < -1 on a stream.", R::Array{0})));
    TEST_EQ(tbl.slice(0, -1).count().run(*conn), (err("RqlRuntimeError", "Cannot slice to an open right index of -1 on a stream.", R::Array{})));
    TEST_EQ(tbl.slice("foo", "bar").count().run(*conn), (err("RqlRuntimeError", "Expected type NUMBER but found STRING.", R::Array{0})));
    TEST_EQ(tbl.slice(1, R::Nil()).count().run(*conn), (err("RqlRuntimeError", "Expected type NUMBER but found NULL.", R::Array{0})));
    TEST_EQ(tbl.slice(R::Nil(), 1).count().run(*conn), (err("RqlRuntimeError", "Expected type NUMBER but found NULL.", R::Array{0})));
    TEST_EQ(tbl.slice(12, 20).count().run(*conn), (8));
    TEST_EQ(tbl.slice(12, 20, R::OptArgs{{"right_bound", R::expr("closed")}}).count().run(*conn), (9));
    TEST_EQ(tbl.slice(12, 20, R::OptArgs{{"left_bound", R::expr("open")}}).count().run(*conn), (7));
    TEST_EQ(tbl.slice(12, 20, R::OptArgs{{"left_bound", R::expr("open")}, {"right_bound", R::expr("closed")}}).count().run(*conn), (8));
    TEST_EQ(tbl.slice(12, -1).count().run(*conn), (err("RqlRuntimeError", "Cannot slice to an open right index of -1 on a stream.", R::Array{})));
    TEST_EQ(tbl.slice(12, -1, R::OptArgs{{"right_bound", R::expr("closed")}}).count().run(*conn), (88));
    TEST_EQ(tbl.slice(12, -2).count().run(*conn), (err("RqlRuntimeError", "Cannot use a right index < -1 on a stream.", R::Array{})));
    TEST_EQ(tbl.slice(12, -2, R::OptArgs{{"right_bound", R::expr("closed")}}).count().run(*conn), (err("RqlRuntimeError", "Cannot use a right index < -1 on a stream.", R::Array{})));
    TEST_EQ(tbl.slice(-12, -2).count().run(*conn), (err("RqlRuntimeError", "Cannot use a negative left index on a stream.", R::Array{})));
    TEST_EQ(tbl.slice(-12, -2, R::OptArgs{{"right_bound", R::expr("closed")}}).count().run(*conn), (err("RqlRuntimeError", "Cannot use a negative left index on a stream.", R::Array{})));
    TEST_EQ(tbl.coerce_to("array").slice(12, 20).count().run(*conn), (8));
    TEST_EQ(tbl.coerce_to("array").slice(12, 20, R::OptArgs{{"right_bound", R::expr("closed")}}).count().run(*conn), (9));
    TEST_EQ(tbl.coerce_to("array").slice(12, 20, R::OptArgs{{"left_bound", R::expr("open")}}).count().run(*conn), (7));
    TEST_EQ(tbl.coerce_to("array").slice(12, 20, R::OptArgs{{"left_bound", R::expr("open")}, {"right_bound", R::expr("closed")}}).count().run(*conn), (8));
    TEST_EQ(tbl.coerce_to("array").slice(12, -1).count().run(*conn), (87));
    TEST_EQ(tbl.coerce_to("array").slice(12, -1, R::OptArgs{{"right_bound", R::expr("closed")}}).count().run(*conn), (88));
    TEST_EQ(tbl.coerce_to("array").slice(12, -2).count().run(*conn), (86));
    TEST_EQ(tbl.coerce_to("array").slice(12, -2, R::OptArgs{{"right_bound", R::expr("closed")}}).count().run(*conn), (87));
    TEST_EQ(tbl.coerce_to("array").slice(-12, -2).count().run(*conn), (10));
    TEST_EQ(tbl.coerce_to("array").slice(-12, -2, R::OptArgs{{"right_bound", R::expr("closed")}}).count().run(*conn), (11));
    TEST_DO(auto arr = (R::expr(R::array(1, 2, 3, 4, 5))));
    TEST_EQ(arr.slice(1, 3).run(*conn), (R::Array{2, 3}));
    TEST_EQ(arr.slice(1, -3).run(*conn), (R::Array{2}));
    TEST_EQ(arr.slice(1).run(*conn), (R::Array{2, 3, 4, 5}));
    TEST_EQ(arr.slice(1, -1).run(*conn), (R::Array{2, 3, 4}));
    TEST_EQ(tbl.order_by("id").nth(1).run(*conn), (R::Object{{"id",1}, {"a",1}}));
    TEST_EQ(tbl.order_by("id").nth(-1).run(*conn), (R::Object{{"id",99}, {"a",3}}));
    TEST_EQ(tbl.order_by("id").nth("foo").count().run(*conn), (err("RqlRuntimeError", "Expected type NUMBER but found STRING.", R::Array{0})));
    TEST_EQ(tbl.is_empty().run(*conn), (false));
    TEST_EQ(tbl.limit(0).is_empty().run(*conn), (true));
    TEST_EQ(R::expr(1).is_empty().run(*conn), (err("RqlRuntimeError", "Cannot convert NUMBER to SEQUENCE", R::Array{})));
    TEST_EQ(R::expr("").is_empty().run(*conn), (err("RqlRuntimeError", "Cannot convert STRING to SEQUENCE", R::Array{})));
    TEST_EQ(tbl3.pluck().nth(0).run(*conn), (R::Object{}));
    TEST_EQ(tbl3.pluck(R::object()).nth(0).run(*conn), (R::Object{}));
    TEST_EQ(tbl3.pluck(R::array()).nth(0).run(*conn), (R::Object{}));
    TEST_EQ(tbl3.pluck("id").order_by("id").nth(0).run(*conn), (R::Object{{"id",0}}));
    TEST_EQ(tbl3.pluck(R::array("id")).order_by("id").nth(0).run(*conn), (R::Object{{"id",0}}));
    TEST_EQ(tbl3.pluck(R::object("id", true)).order_by("id").nth(0).run(*conn), (R::Object{{"id",0}}));
    TEST_EQ(tbl3.pluck("id", "a").order_by("id").nth(0).run(*conn), (R::Object{{"id",0}, {"a",0}}));
    TEST_EQ(tbl3.pluck(R::array("id", "a")).order_by("id").nth(0).run(*conn), (R::Object{{"id",0}, {"a",0}}));
    TEST_EQ(tbl3.pluck(R::object("id", true, "a", true)).order_by("id").nth(0).run(*conn), (R::Object{{"id",0}, {"a",0}}));
    TEST_EQ(tbl3.pluck("id", "missing").order_by("id").nth(0).run(*conn), (R::Object{{"id",0}}));
    TEST_EQ(tbl3.pluck(R::array("id", "missing")).order_by("id").nth(0).run(*conn), (R::Object{{"id",0}}));
    TEST_EQ(tbl3.pluck(R::object("id", true, "missing", true)).order_by("id").nth(0).run(*conn), (R::Object{{"id",0}}));
    TEST_EQ(tbl3.pluck("id", R::object("b", "c")).order_by("id").nth(0).run(*conn), (R::Object{{"id",0}, {"b",R::Object{{"c",0}}}}));
    TEST_EQ(tbl3.pluck(R::array("id", R::object("b", "c"))).order_by("id").nth(0).run(*conn), (R::Object{{"id",0}, {"b",R::Object{{"c",0}}}}));
    TEST_EQ(tbl3.pluck(1).run(*conn), (err("RqlRuntimeError", "Invalid path argument `1`.", R::Array{})));
    TEST_EQ(R::expr(R::array(R::array(R::object("foo", 1)))).pluck("foo").run(*conn), (err("RqlRuntimeError", "Cannot perform pluck on a sequence of sequences.", R::Array{})));
    TEST_EQ(R::expr(R::array("a", "b")).map([=](R::Var x){ return R::expr(R::object("a", 1, "b", 2)).pluck(*x); }).run(*conn), (R::Array{R::Object{{"a",1}}, R::Object{{"b",2}}}));
    TEST_EQ(R::expr(R::object("foo", R::object("bar", 1))).pluck(R::object("foo", R::object("bar", "buzz"))).run(*conn), (R::Object{{"foo",R::Object{}}}));
    TEST_EQ(tbl.without().order_by("id").nth(0).run(*conn), (R::Object{{"id",0}, {"a",0}}));
    TEST_EQ(tbl.without("a").order_by("id").nth(0).run(*conn), (R::Object{{"id",0}}));
    TEST_EQ(tbl.without("id", "a").nth(0).run(*conn), (R::Object{}));
    TEST_EQ(tbl.without("a", "missing").order_by("id").nth(0).run(*conn), (R::Object{{"id",0}}));
    TEST_EQ(tbl3.without("a", R::object("b", "c")).order_by("id").nth(0).run(*conn), (R::Object{{"id",0}, {"b",R::Object{}}}));
    TEST_EQ(tbl3.without(R::array("a", R::object("b", "c"))).order_by("id").nth(0).run(*conn), (R::Object{{"id",0}, {"b",R::Object{}}}));
    TEST_EQ(tbl3.without(R::array("a", R::object("b", "d"))).order_by("id").nth(0).run(*conn), (R::Object{{"id",0}, {"b",R::Object{{"c",0}}}}));
    TEST_EQ(tbl.limit(5).type_of().run(*conn), ("SELECTION<STREAM>"));
    TEST_EQ(tbl.limit(5).coerce_to("array").type_of().run(*conn), ("ARRAY"));
    TEST_EQ(tbl.union_(tbl2).count().run(*conn), (200));
    TEST_EQ(tbl.union_(R::array(1, 2, 3)).count().run(*conn), (103));
    TEST_EQ(R::expr(R::array(1, 2, 3)).union_(tbl2).count().run(*conn), (103));
    TEST_DO(auto ord = (tbl.order_by("id")));
    TEST_EQ(R::expr(R::array(1, 2, 3, 4)).offsets_of(3).run(*conn), (R::Array{2}));
    TEST_EQ(R::expr(R::array(1)).offsets_of(tbl).run(*conn), (err("RqlRuntimeError", "Expected type DATUM but found TABLE.", R::Array{})));
    TEST_EQ(R::expr(1).do_([=](R::Var x){ return R::expr(R::array(2, 1, 0)).offsets_of(*x); }).run(*conn), (R::Array{1}));
    TEST_EQ(tbl.contains(tbl[0]).run(*conn), (true));
    TEST_EQ(tbl.contains(tbl[0].pluck("id")).run(*conn), (false));
    TEST_EQ(tbl3.filter(R::object("b", R::object("c", 0))).pluck("id").order_by("id").nth(0).run(*conn), (R::Object{{"id",0}}));
    TEST_EQ(tbl3.filter(R::object("b", R::object("c", 6))).run(*conn), (R::Array{}));
    TEST_EQ(tbl3.filter(R::literal(R::object("id", 0))).run(*conn), (R::Array{}));
    TEST_EQ(tbl3.filter(R::object("b", R::literal(R::object("c", 0)))).pluck("id").order_by("id").nth(0).run(*conn), (R::Object{{"id",0}}));
    TEST_EQ(R::db("test").table_drop("test2").run(*conn), (partial(R::Object{{"tables_dropped",1}})));
    TEST_EQ(R::db("test").table_drop("test3").run(*conn), (partial(R::Object{{"tables_dropped",1}})));
    exit_section();
}
