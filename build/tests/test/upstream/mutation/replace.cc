// auto-generated by yaml_to_cxx.py from test/upstream/mutation/replace.yaml
#include "testlib.h"
void test_upstream_mutation_replace() {
    enter_section("test_upstream_mutation_replace: Tests replacement of selections");
    temp_table tbl_table;
    R::Query tbl = tbl_table.table();
    TEST_EQ(tbl.insert(R::range(100).map([=](R::Var i){ return R::object("id", *i); })).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",0.0}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",100}}));
    TEST_EQ(tbl.count().run(*conn), (100));
    TEST_EQ(tbl.get(12).replace([=](R::Var row){ return R::object("id", (*row)["id"]); }).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",0.0}, {"unchanged",1}, {"errors",0.0}, {"skipped",0.0}, {"inserted",0.0}}));
    TEST_EQ(tbl.get(12).replace([=](R::Var row){ return R::object("id", (*row)["id"], "a", (*row)["id"]); }).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",1}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",0.0}}));
    TEST_EQ(tbl.get(13).replace([=](R::Var row){ return R::expr(R::Nil()); }).run(*conn), (R::Object{{"deleted",1}, {"replaced",0.0}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",0.0}}));
    TEST_EQ(tbl.between(10, 20, R::OptArgs{{"right_bound", R::expr("closed")}}).replace([=](R::Var row){ return R::object("a", 1); }).run(*conn), (R::Object{{"first_error","Inserted object must have primary key `id`:\n{\n	\"a\":	1\n}"}, {"deleted",0.0}, {"replaced",0.0}, {"unchanged",0.0}, {"errors",10}, {"skipped",0.0}, {"inserted",0.0}}));
    TEST_EQ(tbl.filter([=](R::Var row){ return (*row)["id"]>=10 && (*row)["id"]<20; }).replace([=](R::Var row){ return R::object("id", (*row)["id"], "a", (*row)["id"]); }).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",8}, {"unchanged",1}, {"errors",0.0}, {"skipped",0.0}, {"inserted",0.0}}));
    TEST_EQ(tbl.get(1).replace(R::object("id", 2, "a", 1)).run(*conn), (R::Object{{"first_error","Primary key `id` cannot be changed (`{\n	\"id\":	1\n}` -> `{\n	\"a\":	1,\n	\"id\":	2\n}`)."}, {"deleted",0.0}, {"replaced",0.0}, {"unchanged",0.0}, {"errors",1}, {"skipped",0.0}, {"inserted",0.0}}));
    TEST_EQ(tbl.get(1).replace(R::object("a", 1)).run(*conn), (R::Object{{"first_error","Inserted object must have primary key `id`:\n{\n	\"a\":	1\n}"}, {"deleted",0.0}, {"replaced",0.0}, {"unchanged",0.0}, {"errors",1}, {"skipped",0.0}, {"inserted",0.0}}));
    TEST_EQ(tbl.get(1).replace(R::object("id", R::row["id"], "a", "b")).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",1}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",0.0}}));
    TEST_EQ(tbl.get(1).replace(R::row.merge(R::object("a", "b"))).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",0.0}, {"unchanged",1}, {"errors",0.0}, {"skipped",0.0}, {"inserted",0.0}}));
    TEST_EQ(tbl.get(1).replace(R::row.merge(R::object("c", R::js("5")))).run(*conn), (err("RqlRuntimeError", "Could not prove function deterministic.  Maybe you want to use the non_atomic flag?", R::Array{0})));
    TEST_EQ(tbl.get(1).replace(R::row.merge(R::object("c", tbl.nth(0)))).run(*conn), (err("RqlRuntimeError", "Could not prove function deterministic.  Maybe you want to use the non_atomic flag?", R::Array{0})));
    TEST_EQ(tbl.get(1).replace(R::row.merge(R::object("c", R::js("5"))), R::OptArgs{{"non_atomic", R::expr(true)}}).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",1}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",0.0}}));
    TEST_EQ(tbl.replace([=](R::Var row){ return R::expr(R::Nil()); }).run(*conn), (R::Object{{"deleted",99}, {"replaced",0.0}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",0.0}}));
    TEST_EQ(tbl.get("sdfjk").replace(R::object("id", "sdfjk"))["inserted"].run(*conn), (1));
    TEST_EQ(tbl.get("sdfjki").replace(R::object("id", "sdfjk"))["errors"].run(*conn), (1));
    exit_section();
}
