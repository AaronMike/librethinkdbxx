// auto-generated by yaml_to_cxx.py from test/upstream/selection.yaml
#include "testlib.h"
void test_upstream_selection() {
    enter_section("test_upstream_selection: Tests that manipulation data in tables");
    temp_table tbl_table;
    R::Query tbl = tbl_table.table();
    temp_table tbl2_table;
    R::Query tbl2 = tbl2_table.table();
    temp_table tbl3_table;
    R::Query tbl3 = tbl3_table.table();
    TEST_EQ(maybe_run(tbl.insert(R::range(100).map([=](R::Var i){ return R::object("id", *i, "a", *i % 4); })), *conn), (R::Object{{"deleted", 0.0}, {"replaced", 0.0}, {"unchanged", 0.0}, {"errors", 0.0}, {"skipped", 0.0}, {"inserted", 100}}));
    TEST_EQ(maybe_run(tbl2.insert(R::range(100).map([=](R::Var i){ return R::object("id", *i, "b", *i % 4); })), *conn), (R::Object{{"deleted", 0.0}, {"replaced", 0.0}, {"unchanged", 0.0}, {"errors", 0.0}, {"skipped", 0.0}, {"inserted", 100}}));
    TEST_EQ(maybe_run(tbl.type_of(), *conn), ("TABLE"));
    TEST_EQ(maybe_run(R::db("missing").table("bar"), *conn), (err("ReqlOpFailedError", "Database `missing` does not exist.", R::Array{0})));
    TEST_EQ(maybe_run(R::db("test").table("missing"), *conn), (err("ReqlOpFailedError", "Table `test.missing` does not exist.", R::Array{0})));
    TEST_EQ(maybe_run(tbl.insert(R::object("id", std::string("\x00", 1))).pluck("errors", "inserted"), *conn), (R::Object{{"errors", 1}, {"inserted", 0}}));
    TEST_EQ(maybe_run(tbl.insert(R::object("id", R::array("embedded", R::array(std::string("null\x00", 5))))).pluck("errors", "inserted"), *conn), (R::Object{{"errors", 1}, {"inserted", 0}}));
    TEST_EQ(maybe_run(tbl3.insert(R::object("id", "\xd0\x97\xd0\xb4\xd1\x80\xd0\xb0\xd0\xb2\xd1\x81\xd1\x82\xd0\xb2\xd1\x83\xd0\xb9", "value", "\xd0\x97\xd0\xb5\xd0\xbc\xd0\xbb\xd1\x8f!")), *conn), (R::Object{{"deleted", 0.0}, {"replaced", 0.0}, {"unchanged", 0.0}, {"errors", 0.0}, {"skipped", 0.0}, {"inserted", 1}}));
    TEST_EQ(maybe_run(tbl3.get("\xd0\x97\xd0\xb4\xd1\x80\xd0\xb0\xd0\xb2\xd1\x81\xd1\x82\xd0\xb2\xd1\x83\xd0\xb9"), *conn), (R::Object{{"id", "\xd0\x97\xd0\xb4\xd1\x80\xd0\xb0\xd0\xb2\xd1\x81\xd1\x82\xd0\xb2\xd1\x83\xd0\xb9"}, {"value", "\xd0\x97\xd0\xb5\xd0\xbc\xd0\xbb\xd1\x8f!"}}));
    TEST_EQ(maybe_run(tbl3.filter(R::object("value", "\xd0\x97\xd0\xb5\xd0\xbc\xd0\xbb\xd1\x8f!")), *conn), (R::Array{R::Object{{"id", "\xd0\x97\xd0\xb4\xd1\x80\xd0\xb0\xd0\xb2\xd1\x81\xd1\x82\xd0\xb2\xd1\x83\xd0\xb9"}, {"value", "\xd0\x97\xd0\xb5\xd0\xbc\xd0\xbb\xd1\x8f!"}}}));
    TEST_EQ(maybe_run(R::db("%"), *conn), (err("ReqlQueryLogicError", "Database name `%` invalid (Use A-Za-z0-9_ only).", R::Array{0})));
    TEST_EQ(maybe_run(R::db("test").table("%"), *conn), (err("ReqlQueryLogicError", "Table name `%` invalid (Use A-Za-z0-9_ only).", R::Array{0})));
    TEST_EQ(maybe_run(tbl.count(), *conn), (100));
    TEST_DO(auto tbl2Name = (tbl2.info().get_field("name")));
    TEST_DO(auto tbl2DbName = (tbl2.info().get_field("db").get_field("name")));
    TEST_EQ(maybe_run(R::db(tbl2DbName).table(tbl2Name, R::OptArgs{{"read_mode", R::expr("outdated")}}).count(), *conn), (100));
    TEST_EQ(maybe_run(R::db(tbl2DbName).table(tbl2Name, R::OptArgs{{"read_mode", R::expr("single")}}).count(), *conn), (100));
    TEST_EQ(maybe_run(R::db(tbl2DbName).table(tbl2Name, R::OptArgs{{"read_mode", R::expr("majority")}}).count(), *conn), (100));
    TEST_EQ(maybe_run(R::db(tbl2DbName).table(tbl2Name, R::OptArgs{{"read_mode", R::expr(R::Nil())}}).count(), *conn), (err("ReqlNonExistenceError", "Expected type STRING but found NULL.")));
    TEST_EQ(maybe_run(R::db(tbl2DbName).table(tbl2Name, R::OptArgs{{"read_mode", R::expr(true)}}).count(), *conn), (err("ReqlQueryLogicError", "Expected type STRING but found BOOL.")));
    TEST_EQ(maybe_run(R::db(tbl2DbName).table(tbl2Name, R::OptArgs{{"read_mode", R::expr("fake")}}).count(), *conn), (err("ReqlQueryLogicError", "Read mode `fake` unrecognized (options are \"majority\", \"single\", and \"outdated\").")));
    TEST_EQ(maybe_run(tbl.get(20).count(), *conn), (2));
    TEST_EQ(maybe_run(tbl.get(20), *conn), (R::Object{{"id", 20}, {"a", 0}}));
    TEST_EQ(maybe_run(tbl.get(2000), *conn), (R::Nil()));
    TEST_DO(auto tblpkey = (R::db("test").table("testpkey")));
    TEST_EQ(maybe_run(R::db("test").table_create("testpkey", R::OptArgs{{"primary_key", R::expr("foo")}}), *conn), (partial(R::Object{{"tables_created", 1}})));
    TEST_EQ(maybe_run(tblpkey.insert(R::object("foo", 10, "a", 10)), *conn), (R::Object{{"deleted", 0.0}, {"replaced", 0.0}, {"unchanged", 0.0}, {"errors", 0.0}, {"skipped", 0.0}, {"inserted", 1}}));
    TEST_EQ(maybe_run(tblpkey.get(10), *conn), (R::Object{{"foo", 10}, {"a", 10}}));
    TEST_EQ(maybe_run(tbl.get_all(), *conn), (R::Array{}));
    TEST_EQ(maybe_run(tbl.get_all(20), *conn), (R::Array{R::Object{{"id", 20}, {"a", 0}}}));
    TEST_EQ(maybe_run(tbl.get_all().type_of(), *conn), ("SELECTION<STREAM>"));
    TEST_EQ(maybe_run(tbl.get_all(20).type_of(), *conn), ("SELECTION<STREAM>"));
    TEST_EQ(maybe_run(tbl.between(2, 1).type_of(), *conn), ("TABLE_SLICE"));
    TEST_EQ(maybe_run(tbl.between(1, 2).type_of(), *conn), ("TABLE_SLICE"));
    TEST_EQ(maybe_run(tbl.between(1, 2, R::OptArgs{{"index", R::expr("id")}}).type_of(), *conn), ("TABLE_SLICE"));
    TEST_EQ(maybe_run(tbl.between(1, 1, R::OptArgs{{"right_bound", R::expr("closed")}}).type_of(), *conn), ("TABLE_SLICE"));
    TEST_EQ(maybe_run(tbl.between(2, 1).type_of(), *conn), ("TABLE_SLICE"));
    TEST_EQ(maybe_run(tbl.between(2, 1, R::OptArgs{{"index", R::expr("id")}}).type_of(), *conn), ("TABLE_SLICE"));
    TEST_EQ(maybe_run(tbl.between(21, 20).count(), *conn), (0));
    TEST_EQ(maybe_run(tbl.between(20, 29).count(), *conn), (9));
    TEST_EQ(maybe_run(tbl.between(-10, 9).count(), *conn), (9));
    TEST_EQ(maybe_run(tbl.between(80, 2000).count(), *conn), (20));
    TEST_EQ(maybe_run(tbl.between(-2000, 2000).count(), *conn), (100));
    TEST_EQ(maybe_run(tbl.between(20, 29, R::OptArgs{{"right_bound", R::expr("closed")}}).count(), *conn), (10));
    TEST_EQ(maybe_run(tbl.between(-10, 9, R::OptArgs{{"right_bound", R::expr("closed")}}).count(), *conn), (10));
    TEST_EQ(maybe_run(tbl.between(80, 2000, R::OptArgs{{"right_bound", R::expr("closed")}}).count(), *conn), (20));
    TEST_EQ(maybe_run(tbl.between(-2000, 2000, R::OptArgs{{"right_bound", R::expr("closed")}}).count(), *conn), (100));
    TEST_EQ(maybe_run(tbl.between(20, 29, R::OptArgs{{"left_bound", R::expr("open")}}).count(), *conn), (8));
    TEST_EQ(maybe_run(tbl.between(-10, 9, R::OptArgs{{"left_bound", R::expr("open")}}).count(), *conn), (9));
    TEST_EQ(maybe_run(tbl.between(80, 2000, R::OptArgs{{"left_bound", R::expr("open")}}).count(), *conn), (19));
    TEST_EQ(maybe_run(tbl.between(-2000, 2000, R::OptArgs{{"left_bound", R::expr("open")}}).count(), *conn), (100));
    TEST_EQ(maybe_run(R::expr(R::array(1, 2, 3)).between(-1, 2), *conn), (err("ReqlQueryLogicError", "Expected type TABLE_SLICE but found DATUM:", R::Array{0})));
    TEST_EQ(maybe_run(tbl.between(R::minval, 2).count(), *conn), (2));
    TEST_EQ(maybe_run(tbl.between(R::minval, 2, R::OptArgs{{"right_bound", R::expr("closed")}}).count(), *conn), (3));
    TEST_EQ(maybe_run(tbl.between(R::minval, 2, R::OptArgs{{"left_bound", R::expr("open")}}).count(), *conn), (2));
    TEST_EQ(maybe_run(tbl.between(2, R::maxval).count(), *conn), (98));
    TEST_EQ(maybe_run(tbl.between(R::Nil(), 2).count(), *conn), (err("ReqlQueryLogicError", "Cannot use `null` in BETWEEN, use `r.minval` or `r.maxval` to denote unboundedness.")));
    TEST_EQ(maybe_run(tbl.between(2, R::Nil()).count(), *conn), (err("ReqlQueryLogicError", "Cannot use `null` in BETWEEN, use `r.minval` or `r.maxval` to denote unboundedness.")));
    TEST_EQ(maybe_run(tbl.between(R::Nil(), R::Nil()).count(), *conn), (err("ReqlQueryLogicError", "Cannot use `null` in BETWEEN, use `r.minval` or `r.maxval` to denote unboundedness.")));
    TEST_EQ(maybe_run(tblpkey.between(9, 11).count(), *conn), (1));
    TEST_EQ(maybe_run(tblpkey.between(11, 12).count(), *conn), (0));
    TEST_EQ(maybe_run(tbl.filter([=](R::Var row){ return (*row)["a"]>2; }).count(), *conn), (25));
    TEST_EQ(maybe_run(tbl.filter([=](R::Var row){ return R::expr(1); }).count(), *conn), (100));
    TEST_EQ(maybe_run(R::expr(R::array(1, 2, 3, 4, 5)).filter(R::row>2).filter(R::row>3), *conn), (R::Array{4, 5}));
    TEST_DO(auto nested = (R::expr(R::array(R::array(1, 2), R::array(3, 4), R::array(5, 6)))));
    TEST_EQ(maybe_run(nested.filter([=](R::Var x){ return (*x).filter([=](R::Var y){ return *y>=4; }).count()>0; }), *conn), (R::Array{R::Array{3, 4}, R::Array{5, 6}}));
    TEST_EQ(maybe_run(nested.filter(R::row.filter([=](R::Var y){ return *y>=4; }).count()>0), *conn), (R::Array{R::Array{3, 4}, R::Array{5, 6}}));
    TEST_EQ(maybe_run(nested.filter([=](R::Var x){ return (*x).filter(R::row>=4).count()>0; }), *conn), (err("ReqlCompileError", "Cannot use r.row in nested queries.  Use functions instead.", R::Array{0})));
    TEST_EQ(maybe_run(R::expr(R::array(R::array(1, 2), R::array(3, 4), R::array(5, 6))).filter(R::row.filter(R::row>=4).count()>0), *conn), (err("ReqlCompileError", "Cannot use r.row in nested queries.  Use functions instead.", R::Array{0})));
    TEST_EQ(maybe_run(R::expr(R::array(R::object("a", 1, "b", 1, "c", 3), R::object("a", 1, "b", 2, "c", 3))).filter(R::object("a", 1, "b", 2)), *conn), (R::Array{R::Object{{"a", 1}, {"b", 2}, {"c", 3}}}));
    TEST_EQ(maybe_run(R::expr(R::array(R::object("a", 1, "b", 1, "c", 3), R::object("a", 1, "b", 2, "c", 3))).filter(R::object("a", 1)), *conn), (R::Array{R::Object{{"a", 1}, {"b", 1}, {"c", 3}}, R::Object{{"a", 1}, {"b", 2}, {"c", 3}}}));
    TEST_EQ(maybe_run(R::expr(R::array(R::object("a", 1, "b", 1, "c", 3), R::object("a", 1, "b", 2, "c", 3))).filter(R::object("a", R::row["b"])), *conn), (R::Array{R::Object{{"a", 1}, {"b", 1}, {"c", 3}}}));
    TEST_EQ(maybe_run(R::expr(R::array(R::object("a", 1))).filter(R::object("b", 1)), *conn), (R::Array{}));
    TEST_EQ(maybe_run(tbl.count([=](R::Var row){ return R::object("a", 1); }), *conn), (25));
    TEST_EQ(maybe_run(R::expr(R::array(1, 2, 3, 1)).count(1), *conn), (2));
    TEST_EQ(maybe_run(R::expr(R::array(R::Nil(), 4, R::Nil(), "foo")).count(R::Nil()), *conn), (2));
    TEST_EQ(maybe_run((R::expr(5) + tbl), *conn), (err("ReqlQueryLogicError", "Expected type DATUM but found TABLE:", R::Array{0})));
    TEST_EQ(maybe_run(tbl.has_fields("field").type_of(), *conn), ("SELECTION<STREAM>"));
    exit_section();
}
