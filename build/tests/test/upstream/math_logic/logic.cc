// auto-generated by yaml_to_cxx.py from test/upstream/math_logic/logic.yaml
#include "testlib.h"
void test_upstream_math_logic_logic() {
    enter_section("test_upstream_math_logic_logic: These tests are aimed at &&, ||, and !");
    TEST_EQ(maybe_run((R::expr(true) && true), *conn), (true));
    TEST_EQ(maybe_run((R::expr(true) && R::expr(true)), *conn), (true));
    TEST_EQ(maybe_run(R::and_(true, true), *conn), (true));
    TEST_EQ(maybe_run(R::expr(true).and_(true), *conn), (true));
    TEST_EQ(maybe_run((R::expr(true) && false), *conn), (false));
    TEST_EQ(maybe_run((R::expr(false) && false), *conn), (false));
    TEST_EQ(maybe_run((R::expr(true) && R::expr(false)), *conn), (false));
    TEST_EQ(maybe_run((R::expr(false) && R::expr(false)), *conn), (false));
    TEST_EQ(maybe_run(R::and_(true, false), *conn), (false));
    TEST_EQ(maybe_run(R::and_(false, false), *conn), (false));
    TEST_EQ(maybe_run(R::expr(true).and_(false), *conn), (false));
    TEST_EQ(maybe_run(R::expr(false).and_(false), *conn), (false));
    TEST_EQ(maybe_run((R::expr(true) || true), *conn), (true));
    TEST_EQ(maybe_run((R::expr(true) || false), *conn), (true));
    TEST_EQ(maybe_run((R::expr(true) || R::expr(true)), *conn), (true));
    TEST_EQ(maybe_run((R::expr(true) || R::expr(false)), *conn), (true));
    TEST_EQ(maybe_run(R::or_(true, true), *conn), (true));
    TEST_EQ(maybe_run(R::or_(true, false), *conn), (true));
    TEST_EQ(maybe_run(R::expr(true).or_(true), *conn), (true));
    TEST_EQ(maybe_run(R::expr(true).or_(false), *conn), (true));
    TEST_EQ(maybe_run((R::expr(false) || false), *conn), (false));
    TEST_EQ(maybe_run((R::expr(false) || R::expr(false)), *conn), (false));
    TEST_EQ(maybe_run(R::and_(false, false), *conn), (false));
    TEST_EQ(maybe_run(R::expr(false).and_(false), *conn), (false));
    TEST_EQ(maybe_run((!R::expr(true)), *conn), (false));
    TEST_EQ(maybe_run(R::not_(true), *conn), (false));
    TEST_EQ(maybe_run((!R::expr(false)), *conn), (true));
    TEST_EQ(maybe_run(R::not_(false), *conn), (true));
    TEST_EQ(maybe_run(R::expr(true).not_(), *conn), (false));
    TEST_EQ(maybe_run(R::expr(false).not_(), *conn), (true));
    TEST_EQ(maybe_run((!R::and_(true, true)==R::or_(!R::expr(true), !R::expr(true))), *conn), (true));
    TEST_EQ(maybe_run((!R::and_(true, false)==R::or_(!R::expr(true), !R::expr(false))), *conn), (true));
    TEST_EQ(maybe_run((!R::and_(false, false)==R::or_(!R::expr(false), !R::expr(false))), *conn), (true));
    TEST_EQ(maybe_run((!R::and_(false, true)==R::or_(!R::expr(false), !R::expr(true))), *conn), (true));
    TEST_EQ(maybe_run(R::and_(true, true, true, true, true), *conn), (true));
    TEST_EQ(maybe_run(R::and_(true, true, true, false, true), *conn), (false));
    TEST_EQ(maybe_run(R::and_(true, false, true, false, true), *conn), (false));
    TEST_EQ(maybe_run(R::or_(false, false, false, false, false), *conn), (false));
    TEST_EQ(maybe_run(R::or_(false, false, false, true, false), *conn), (true));
    TEST_EQ(maybe_run(R::or_(false, true, false, true, false), *conn), (true));
    TEST_EQ(maybe_run(R::expr(R::expr("a")["b"]).default_(2), *conn), (err("ReqlQueryLogicError", "Cannot perform bracket on a non-object non-sequence `\"a\"`.", R::Array{})));
    TEST_EQ(maybe_run(R::expr(R::and_(true, false)==R::or_(false, true)), *conn), (false));
    TEST_EQ(maybe_run(R::expr(R::and_(true, false)>=R::or_(false, true)), *conn), (false));
    TEST_EQ(maybe_run((R::expr(1) && true), *conn), (true));
    TEST_EQ(maybe_run((R::expr(false) || "str"), *conn), ("str"));
    TEST_EQ(maybe_run((!R::expr(1)), *conn), (false));
    TEST_EQ(maybe_run((!R::expr(R::Nil())), *conn), (true));
    exit_section();
}
