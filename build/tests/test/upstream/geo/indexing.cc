// auto-generated by yaml_to_cxx.py from test/upstream/geo/indexing.yaml
#include "testlib.h"
void test_upstream_geo_indexing() {
    enter_section("test_upstream_geo_indexing: Test ReQL interface to geo indexes");
    temp_table tbl_table;
    R::Query tbl = tbl_table.table();
    auto rows = R::Array{R::Object{{"id",0}, {"g",R::point(10, 10)}, {"m",R::Array{R::point(0, 0), R::point(1, 0), R::point(2, 0)}}}, R::Object{{"id",1}, {"g",R::polygon(R::array(0, 0), R::array(0, 1), R::array(1, 1), R::array(1, 0))}}, R::Object{{"id",2}, {"g",R::line(R::array(2e-06, -1), R::array(-1e-06, 1))}}};
    TEST_EQ(tbl.insert(rows).run(*conn), (R::Object{{"deleted",0}, {"inserted",3}, {"skipped",0}, {"errors",0}, {"replaced",0}, {"unchanged",0}}));
    TEST_EQ(tbl.index_create("g", R::OptArgs{{"geo", R::expr(true)}}).run(*conn), (R::Object{{"created",1}}));
    TEST_EQ(tbl.index_create("m", R::OptArgs{{"geo", R::expr(true)}, {"multi", R::expr(true)}}).run(*conn), (R::Object{{"created",1}}));
    TEST_EQ(tbl.index_create("other").run(*conn), (R::Object{{"created",1}}));
    TEST_EQ(tbl.index_create("point_det", [=](R::Var x){ return R::point(*x, *x); }).run(*conn), (R::Object{{"created",1}}));
    tbl.index_wait().run(*conn);
    TEST_EQ(tbl.get_intersecting(R::point(0, 0), R::OptArgs{{"index", R::expr("other")}}).count().run(*conn), (err("RqlRuntimeError", "Index `other` is not a geospatial index.  get_intersecting can only be used with a geospatial index.", R::Array{0})));
    TEST_EQ(tbl.get_intersecting(R::point(0, 0), R::OptArgs{{"index", R::expr("missing")}}).count().run(*conn), (err_regex("RqlRuntimeError", "Index `missing` was not found on table `[a-zA-Z0-9_]+.[a-zA-Z0-9_]+`[.]", R::Array{0})));
    TEST_EQ(tbl.get_intersecting(R::point(0, 0)).count().run(*conn), (err("RqlRuntimeError", "get_intersecting requires an index argument.", R::Array{0})));
    TEST_EQ(tbl.get_all(0, R::OptArgs{{"index", R::expr("g")}}).count().run(*conn), (err("RqlRuntimeError", "Index `g` is a geospatial index.  Only get_nearest and get_intersecting can use a geospatial index.", R::Array{0})));
    TEST_EQ(tbl.between(0, 1, R::OptArgs{{"index", R::expr("g")}}).count().run(*conn), (err("RqlRuntimeError", "Index `g` is a geospatial index.  Only get_nearest and get_intersecting can use a geospatial index.", R::Array{0})));
    TEST_EQ(tbl.order_by(R::OptArgs{{"index", R::expr("g")}}).count().run(*conn), (err("RqlRuntimeError", "Index `g` is a geospatial index.  Only get_nearest and get_intersecting can use a geospatial index.", R::Array{0})));
    TEST_EQ(tbl.get_intersecting(R::point(0, 0), R::OptArgs{{"index", R::expr("id")}}).count().run(*conn), (err("RqlRuntimeError", "get_intersecting cannot use the primary index.", R::Array{0})));
    TEST_EQ(tbl.get_intersecting(R::point(0, 0), R::OptArgs{{"index", R::expr("g")}}).count().run(*conn), (1));
    TEST_EQ(tbl.get_intersecting(R::point(10, 10), R::OptArgs{{"index", R::expr("g")}}).count().run(*conn), (1));
    TEST_EQ(tbl.get_intersecting(R::point(0.5, 0.5), R::OptArgs{{"index", R::expr("g")}}).count().run(*conn), (1));
    TEST_EQ(tbl.get_intersecting(R::point(20, 20), R::OptArgs{{"index", R::expr("g")}}).count().run(*conn), (0));
    TEST_EQ(tbl.get_intersecting(R::polygon(R::array(0, 0), R::array(1, 0), R::array(1, 1), R::array(0, 1)), R::OptArgs{{"index", R::expr("g")}}).count().run(*conn), (2));
    TEST_EQ(tbl.get_intersecting(R::line(R::array(0, 0), R::array(10, 10)), R::OptArgs{{"index", R::expr("g")}}).count().run(*conn), (3));
    TEST_EQ(tbl.get_intersecting(R::point(0, 0), R::OptArgs{{"index", R::expr("g")}}).type_of().run(*conn), ("SELECTION<STREAM>"));
    TEST_EQ(tbl.get_intersecting(R::point(0, 0), R::OptArgs{{"index", R::expr("g")}}).filter(true).type_of().run(*conn), ("SELECTION<STREAM>"));
    TEST_EQ(tbl.get_intersecting(R::point(0, 0), R::OptArgs{{"index", R::expr("g")}}).map(R::row).type_of().run(*conn), ("STREAM"));
    TEST_EQ(tbl.get_intersecting(R::point(0, 0), R::OptArgs{{"index", R::expr("m")}}).count().run(*conn), (1));
    TEST_EQ(tbl.get_intersecting(R::point(1, 0), R::OptArgs{{"index", R::expr("m")}}).count().run(*conn), (1));
    TEST_EQ(tbl.get_intersecting(R::point(2, 0), R::OptArgs{{"index", R::expr("m")}}).count().run(*conn), (1));
    TEST_EQ(tbl.get_intersecting(R::point(3, 0), R::OptArgs{{"index", R::expr("m")}}).count().run(*conn), (0));
    TEST_EQ(tbl.get_intersecting(R::polygon(R::array(0, 0), R::array(0, 1), R::array(1, 1), R::array(1, 0)), R::OptArgs{{"index", R::expr("m")}}).count().run(*conn), (1));
    TEST_EQ(tbl.get_nearest(R::point(0, 0), R::OptArgs{{"index", R::expr("other")}}).run(*conn), (err("RqlRuntimeError", "Index `other` is not a geospatial index.  get_nearest can only be used with a geospatial index.", R::Array{0})));
    TEST_EQ(tbl.get_nearest(R::point(0, 0), R::OptArgs{{"index", R::expr("missing")}}).run(*conn), (err_regex("RqlRuntimeError", "Index `missing` was not found on table `[a-zA-Z0-9_]+.[a-zA-Z0-9_]+`[.]", R::Array{0})));
    TEST_EQ(tbl.get_nearest(R::point(0, 0)).run(*conn), (err("RqlRuntimeError", "get_nearest requires an index argument.", R::Array{0})));
    TEST_EQ(tbl.get_nearest(R::point(0, 0), R::OptArgs{{"index", R::expr("id")}}).count().run(*conn), (err("RqlRuntimeError", "get_nearest cannot use the primary index.", R::Array{0})));
    TEST_EQ(tbl.get_nearest(R::point(0, 0), R::OptArgs{{"index", R::expr("g")}}).pluck("dist", R::object("doc", "id")).run(*conn), (R::Array{R::Object{{"dist",0}, {"doc",R::Object{{"id",1}}}}, R::Object{{"dist",0.055659745396754216}, {"doc",R::Object{{"id",2}}}}}));
    TEST_EQ(tbl.get_nearest(R::point(-1e-06, 1), R::OptArgs{{"index", R::expr("g")}}).pluck("dist", R::object("doc", "id")).run(*conn), (R::Array{R::Object{{"dist",0}, {"doc",R::Object{{"id",2}}}}, R::Object{{"dist",0.11130264976984369}, {"doc",R::Object{{"id",1}}}}}));
    TEST_EQ(tbl.get_nearest(R::point(0, 0), R::OptArgs{{"index", R::expr("g")}, {"max_dist", R::expr(1565110)}}).pluck("dist", R::object("doc", "id")).run(*conn), (R::Array{R::Object{{"dist",0}, {"doc",R::Object{{"id",1}}}}, R::Object{{"dist",0.055659745396754216}, {"doc",R::Object{{"id",2}}}}, R::Object{{"dist",1565109.0992178896}, {"doc",R::Object{{"id",0}}}}}));
    TEST_EQ(tbl.get_nearest(R::point(0, 0), R::OptArgs{{"index", R::expr("g")}, {"max_dist", R::expr(1565110)}, {"max_results", R::expr(2)}}).pluck("dist", R::object("doc", "id")).run(*conn), (R::Array{R::Object{{"dist",0}, {"doc",R::Object{{"id",1}}}}, R::Object{{"dist",0.055659745396754216}, {"doc",R::Object{{"id",2}}}}}));
    TEST_EQ(tbl.get_nearest(R::point(0, 0), R::OptArgs{{"index", R::expr("g")}, {"max_dist", R::expr(10000000)}}).pluck("dist", R::object("doc", "id")).run(*conn), (err("RqlRuntimeError", "The distance has become too large for continuing the indexed nearest traversal.  Consider specifying a smaller `max_dist` parameter.  (Radius must be smaller than a quarter of the circumference along the minor axis of the reference ellipsoid.  Got 10968937.995244588703m, but must be smaller than 9985163.1855612862855m.)", R::Array{0})));
    TEST_EQ(tbl.get_nearest(R::point(0, 0), R::OptArgs{{"index", R::expr("g")}, {"max_dist", R::expr(1566)}, {"unit", R::expr("km")}}).pluck("dist", R::object("doc", "id")).run(*conn), (R::Array{R::Object{{"dist",0}, {"doc",R::Object{{"id",1}}}}, R::Object{{"dist",5.565974539675422e-05}, {"doc",R::Object{{"id",2}}}}, R::Object{{"dist",1565.1090992178897}, {"doc",R::Object{{"id",0}}}}}));
    TEST_EQ(tbl.get_nearest(R::point(0, 0), R::OptArgs{{"index", R::expr("g")}, {"max_dist", R::expr(1)}, {"geo_system", R::expr("unit_sphere")}}).pluck("dist", R::object("doc", "id")).run(*conn), (R::Array{R::Object{{"dist",0}, {"doc",R::Object{{"id",1}}}}, R::Object{{"dist",8.726646259990191e-09}, {"doc",R::Object{{"id",2}}}}, R::Object{{"dist",0.24619691677893205}, {"doc",R::Object{{"id",0}}}}}));
    TEST_EQ(tbl.get_nearest(R::point(0, 0), R::OptArgs{{"index", R::expr("g")}}).type_of().run(*conn), ("ARRAY"));
    TEST_EQ(tbl.get_nearest(R::point(0, 0), R::OptArgs{{"index", R::expr("g")}}).map(R::row).type_of().run(*conn), ("ARRAY"));
}
