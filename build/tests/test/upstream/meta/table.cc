// auto-generated by yaml_to_cxx.py from test/upstream/meta/table.yaml
#include "testlib.h"
void test_upstream_meta_table() {
    enter_section("test_upstream_meta_table: Tests meta queries for creating and deleting tables");
    TEST_DO(auto db = (R::db("test")));
    TEST_EQ(maybe_run(db.table_list(), *conn), (R::Array{}));
    TEST_EQ(maybe_run(R::db("rethinkdb").info(), *conn), (R::Object{{"type", "DB"}, {"name", "rethinkdb"}, {"id", R::Nil()}}));
    TEST_EQ(maybe_run(R::db("rethinkdb").table("stats").info(), *conn), (partial(R::Object{{"db", R::Object{{"type", "DB"}, {"name", "rethinkdb"}, {"id", R::Nil()}}}, {"type", "TABLE"}, {"id", R::Nil()}, {"name", "stats"}, {"indexes", R::Array{}}, {"primary_key", "id"}})));
    TEST_EQ(maybe_run(db.table_create("a"), *conn), (partial(R::Object{{"tables_created", 1}})));
    TEST_EQ(maybe_run(db.table_list(), *conn), (R::Array{"a"}));
    TEST_EQ(maybe_run(db.table_create("b"), *conn), (partial(R::Object{{"tables_created", 1}})));
    TEST_EQ(maybe_run(db.table_list(), *conn), (bag(R::Array{"a", "b"})));
    TEST_EQ(maybe_run(db.table_drop("a"), *conn), (partial(R::Object{{"tables_dropped", 1}})));
    TEST_EQ(maybe_run(db.table_list(), *conn), (R::Array{"b"}));
    TEST_EQ(maybe_run(db.table_drop("b"), *conn), (partial(R::Object{{"tables_dropped", 1}})));
    TEST_EQ(maybe_run(db.table_list(), *conn), (R::Array{}));
    TEST_EQ(maybe_run(db.table_create("ab", R::OptArgs{{"durability", R::expr("soft")}}), *conn), (partial(R::Object{{"tables_created", 1}, {"config_changes", R::Array{partial(R::Object{{"new_val", partial(R::Object{{"durability", "soft"}})}})}}})));
    TEST_EQ(maybe_run(db.table_drop("ab"), *conn), (partial(R::Object{{"tables_dropped", 1}})));
    TEST_EQ(maybe_run(db.table_create("ab", R::OptArgs{{"durability", R::expr("hard")}}), *conn), (partial(R::Object{{"tables_created", 1}, {"config_changes", R::Array{partial(R::Object{{"new_val", partial(R::Object{{"durability", "hard"}})}})}}})));
    TEST_EQ(maybe_run(db.table_drop("ab"), *conn), (partial(R::Object{{"tables_dropped", 1}})));
    TEST_EQ(maybe_run(db.table_create("ab", R::OptArgs{{"durability", R::expr("fake")}}), *conn), (err("ReqlQueryLogicError", "Durability option `fake` unrecognized (options are \"hard\" and \"soft\").")));
    TEST_EQ(maybe_run(db.table_create("ab", R::OptArgs{{"primary_key", R::expr("bar")}, {"shards", R::expr(2)}, {"replicas", R::expr(1)}}), *conn), (partial(R::Object{{"tables_created", 1}})));
    TEST_EQ(maybe_run(db.table_drop("ab"), *conn), (partial(R::Object{{"tables_dropped", 1}})));
    TEST_EQ(maybe_run(db.table_create("ab", R::OptArgs{{"primary_key", R::expr("bar")}, {"primary_replica_tag", R::expr("default")}}), *conn), (partial(R::Object{{"tables_created", 1}})));
    TEST_EQ(maybe_run(db.table_drop("ab"), *conn), (partial(R::Object{{"tables_dropped", 1}})));
    TEST_EQ(maybe_run(db.table_create("ab", R::OptArgs{{"nonvoting_replica_tags", R::expr(R::array("default"))}}), *conn), (partial(R::Object{{"tables_created", 1}})));
    TEST_EQ(maybe_run(db.table_drop("ab"), *conn), (partial(R::Object{{"tables_dropped", 1}})));
    TEST_EQ(maybe_run(db.table_create("a"), *conn), (partial(R::Object{{"tables_created", 1}})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"shards", R::expr(1)}, {"replicas", R::expr(1)}}), *conn), (partial(R::Object{{"reconfigured", 1}})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"shards", R::expr(1)}, {"replicas", R::expr(R::object("default", 1))}, {"nonvoting_replica_tags", R::expr(R::array("default"))}, {"primary_replica_tag", R::expr("default")}}), *conn), (partial(R::Object{{"reconfigured", 1}})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"shards", R::expr(1)}, {"replicas", R::expr(1)}, {"dry_run", R::expr(true)}}), *conn), (partial(R::Object{{"reconfigured", 0}})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"emergency_repair", R::expr("unsafe_rollback")}}), *conn), (err("ReqlOpFailedError", "This table doesn't need to be repaired.", R::Array{})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"emergency_repair", R::expr("unsafe_rollback")}, {"dry_run", R::expr(true)}}), *conn), (err("ReqlOpFailedError", "This table doesn't need to be repaired.", R::Array{})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"emergency_repair", R::expr("unsafe_rollback_or_erase")}}), *conn), (err("ReqlOpFailedError", "This table doesn't need to be repaired.", R::Array{})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"emergency_repair", R::expr(R::Nil())}, {"shards", R::expr(1)}, {"replicas", R::expr(1)}, {"dry_run", R::expr(true)}}), *conn), (partial(R::Object{{"reconfigured", 0}})));
    TEST_EQ(maybe_run(db.table_drop("a"), *conn), (partial(R::Object{{"tables_dropped", 1}})));
    TEST_EQ(maybe_run(db.table_create("foo"), *conn), (partial(R::Object{{"tables_created", 1}})));
    TEST_EQ(maybe_run(db.table_create("foo"), *conn), (err("ReqlOpFailedError", "Table `test.foo` already exists.", R::Array{0})));
    TEST_EQ(maybe_run(db.table_drop("foo"), *conn), (partial(R::Object{{"tables_dropped", 1}})));
    TEST_EQ(maybe_run(db.table_drop("foo"), *conn), (err("ReqlOpFailedError", "Table `test.foo` does not exist.", R::Array{0})));
    TEST_EQ(maybe_run(db.table_create("nonsense", R::OptArgs{{"foo", R::expr("bar")}}), *conn), (err("ReqlCompileError", "Unrecognized optional argument `foo`.", R::Array{})));
    TEST_EQ(maybe_run(db.table_create("a"), *conn), (partial(R::Object{{"tables_created", 1}})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"shards", R::expr(0)}, {"replicas", R::expr(1)}}), *conn), (err("ReqlQueryLogicError", "Every table must have at least one shard.", R::Array{})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"shards", R::expr(1)}, {"replicas", R::expr(R::object("default", 1))}, {"primary_replica_tag", R::expr("foo")}}), *conn), (err("ReqlOpFailedError", "Can't use server tag `foo` for primary replicas because you specified no replicas in server tag `foo`.", R::Array{})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"shards", R::expr(1)}, {"replicas", R::expr(R::object("default", 1))}, {"primary_replica_tag", R::expr("default")}, {"nonvoting_replica_tags", R::expr(R::array("foo"))}}), *conn), (err("ReqlOpFailedError", "You specified that the replicas in server tag `foo` should be non-voting, but you didn't specify a number of replicas in server tag `foo`.", R::Array{})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"shards", R::expr(1)}, {"replicas", R::expr(R::object("foo", 0))}, {"primary_replica_tag", R::expr("foo")}}), *conn), (err("ReqlOpFailedError", "You must set `replicas` to at least one. `replicas` includes the primary replica; if there are zero replicas, there is nowhere to put the data.", R::Array{})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"shards", R::expr(1)}, {"replicas", R::expr(R::object("default", 0))}}), *conn), (err("ReqlQueryLogicError", "`primary_replica_tag` must be specified when `replicas` is an OBJECT.", R::Array{})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"shards", R::expr(1)}, {"replicas", R::expr(R::object("default", -3))}, {"primary_replica_tag", R::expr("default")}}), *conn), (err("ReqlQueryLogicError", "Can't have a negative number of replicas", R::Array{})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"shards", R::expr(1)}, {"replicas", R::expr(3)}, {"primary_replica_tag", R::expr("foo")}}), *conn), (err("ReqlQueryLogicError", "`replicas` must be an OBJECT if `primary_replica_tag` is specified.", R::Array{})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"shards", R::expr(1)}, {"replicas", R::expr(3)}, {"nonvoting_replica_tags", R::expr(R::array("foo"))}}), *conn), (err("ReqlQueryLogicError", "`replicas` must be an OBJECT if `nonvoting_replica_tags` is specified.", R::Array{})));
    TEST_EQ(maybe_run(db.reconfigure(R::OptArgs{{"emergency_repair", R::expr("unsafe_rollback")}}), *conn), (err("ReqlQueryLogicError", "Can't emergency repair an entire database at once; instead you should run `reconfigure()` on each table individually.")));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"emergency_repair", R::expr("foo")}}), *conn), (err("ReqlQueryLogicError", "`emergency_repair` should be \"unsafe_rollback\" or \"unsafe_rollback_or_erase\"", R::Array{})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"emergency_repair", R::expr("unsafe_rollback")}, {"shards", R::expr(1)}, {"replicas", R::expr(1)}}), *conn), (err("ReqlQueryLogicError", "In emergency repair mode, you can't specify shards, replicas, etc.")));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"shards", R::expr(2)}, {"replicas", R::expr(1)}}), *conn), (partial(R::Object{{"reconfigured", 1}})));
    TEST_EQ(maybe_run(db.table("a").wait(R::OptArgs{{"wait_for", R::expr("all_replicas_ready")}}), *conn), (R::Object{{"ready", 1}}));
    TEST_EQ(maybe_run(db.table("a").insert(R::array(R::object("id", 1), R::object("id", 2), R::object("id", 3), R::object("id", 4))), *conn), (partial(R::Object{{"inserted", 4}})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"shards", R::expr(2)}, {"replicas", R::expr(1)}}), *conn), (partial(R::Object{{"reconfigured", 1}})));
    TEST_EQ(maybe_run(db.table("a").reconfigure(R::OptArgs{{"shards", R::expr(1)}, {"replicas", R::expr(2)}}), *conn), (err("ReqlOpFailedError", "Can't put 2 replicas on servers with the tag `default` because there are only 1 servers with the tag `default`. It's impossible to have more replicas of the data than there are servers.", R::Array{})));
    TEST_EQ(maybe_run(db.table("a").wait(R::OptArgs{{"wait_for", R::expr("all_replicas_ready")}}), *conn), (R::Object{{"ready", 1}}));
    TEST_EQ(maybe_run(db.table("a").rebalance(), *conn), (partial(R::Object{{"rebalanced", 1}})));
    TEST_EQ(maybe_run(db.wait(R::OptArgs{{"wait_for", R::expr("all_replicas_ready")}}), *conn), (R::Object{{"ready", 1}}));
    TEST_EQ(maybe_run(db.rebalance(), *conn), (partial(R::Object{{"rebalanced", 1}})));
    TEST_EQ(maybe_run(R::wait(), *conn), (err("AttributeError", "'module' object has no attribute 'wait'", R::Array{})));
    TEST_EQ(maybe_run(R::rebalance(), *conn), (err("AttributeError", "'module' object has no attribute 'rebalance'", R::Array{})));
    TEST_EQ(maybe_run(db.table_drop("a"), *conn), (partial(R::Object{{"tables_dropped", 1}})));
    TEST_DO(maybe_run(db.table_create("a"), *conn));
    TEST_DO(maybe_run(db.table_create("b"), *conn));
    TEST_DO(maybe_run(db.table_create("c"), *conn));
    TEST_EQ(maybe_run(db.reconfigure(R::OptArgs{{"shards", R::expr(0)}, {"replicas", R::expr(1)}}), *conn), (err("ReqlQueryLogicError", "Every table must have at least one shard.", R::Array{})));
    TEST_EQ(maybe_run(db.reconfigure(R::OptArgs{{"shards", R::expr(1)}, {"replicas", R::expr(R::object("default", 0))}}), *conn), (err("ReqlQueryLogicError", "`primary_replica_tag` must be specified when `replicas` is an OBJECT.", R::Array{})));
    TEST_EQ(maybe_run(db.reconfigure(R::OptArgs{{"shards", R::expr(1)}, {"replicas", R::expr(R::object("default", -3))}, {"primary_replica_tag", R::expr("default")}}), *conn), (err("ReqlQueryLogicError", "Can't have a negative number of replicas", R::Array{})));
    TEST_EQ(maybe_run(db.reconfigure(R::OptArgs{{"shards", R::expr(1)}, {"replicas", R::expr(3)}, {"primary_replica_tag", R::expr("foo")}}), *conn), (err("ReqlQueryLogicError", "`replicas` must be an OBJECT if `primary_replica_tag` is specified.", R::Array{})));
    TEST_EQ(maybe_run(db.reconfigure(R::OptArgs{{"shards", R::expr(2)}, {"replicas", R::expr(1)}}), *conn), (partial(R::Object{{"reconfigured", 3}})));
    TEST_EQ(maybe_run(db.table_drop("a"), *conn), (partial(R::Object{{"tables_dropped", 1}})));
    TEST_EQ(maybe_run(db.table_drop("b"), *conn), (partial(R::Object{{"tables_dropped", 1}})));
    TEST_EQ(maybe_run(db.table_drop("c"), *conn), (partial(R::Object{{"tables_dropped", 1}})));
    TEST_EQ(maybe_run(R::db_create("test2"), *conn), (partial(R::Object{{"dbs_created", 1}})));
    TEST_DO(auto db2 = (R::db("test2")));
    TEST_EQ(maybe_run(db.table_create("testA"), *conn), (partial(R::Object{{"tables_created", 1}})));
    TEST_EQ(maybe_run(db.table_create("testB"), *conn), (partial(R::Object{{"tables_created", 1}})));
    TEST_EQ(maybe_run(db2.table_create("test2B"), *conn), (partial(R::Object{{"tables_created", 1}})));
    TEST_EQ(maybe_run(R::table("testA").config().pluck("db", "name"), *conn), (R::Object{{"db", "test"}, {"name", "testA"}}));
    TEST_EQ(maybe_run(R::table("doesntexist").config(), *conn), (err("ReqlOpFailedError", "Table `test.doesntexist` does not exist.", R::Array{})));
    TEST_EQ(maybe_run(R::table("test2B").config(), *conn), (err("ReqlOpFailedError", "Table `test.test2B` does not exist.", R::Array{})));
    TEST_EQ(maybe_run(R::db("rethinkdb").table("table_config").filter(R::object("name", "testA")).nth(0).eq(R::table("testA").config()), *conn), (true));
    TEST_EQ(maybe_run(R::db("rethinkdb").table("table_status").filter(R::object("name", "testA")).nth(0).eq(R::table("testA").status()), *conn), (true));
    TEST_EQ(maybe_run(R::db("rethinkdb").table("table_config", R::OptArgs{{"identifier_format", R::expr("uuid")}}).nth(0)["db"], *conn), (uuid()));
    TEST_EQ(maybe_run(R::table("testA", R::OptArgs{{"identifier_format", R::expr("uuid")}}).count(), *conn), (0));
    TEST_EQ(maybe_run(R::wait(R::OptArgs{{"wait_for", R::expr("all_replicas_ready")}, {"timeout", R::expr(5)}}), *conn), (err("AttributeError", "'module' object has no attribute 'wait'", R::Array{})));
    TEST_EQ(maybe_run(db.table_drop("testA"), *conn), (partial(R::Object{{"tables_dropped", 1}})));
    TEST_EQ(maybe_run(db.table_drop("testB"), *conn), (partial(R::Object{{"tables_dropped", 1}})));
    TEST_EQ(maybe_run(R::db_drop("test2"), *conn), (partial(R::Object{{"dbs_dropped", 1}, {"tables_dropped", 1}})));
    exit_section();
}
