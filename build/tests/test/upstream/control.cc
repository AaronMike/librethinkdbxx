// auto-generated by yaml_to_cxx.py from test/upstream/control.yaml
#include "testlib.h"
void test_upstream_control() {
    enter_section("test_upstream_control: Tests RQL control flow structures");
    temp_table tbl_table;
    R::Query tbl = tbl_table.table();
    temp_table tbl2_table;
    R::Query tbl2 = tbl2_table.table();
    TEST_EQ(R::expr(1).do_([=](R::Var v){ return *v * 2; }).run(*conn), (2));
    TEST_EQ(R::expr(R::array(0, 1, 2)).do_([=](R::Var v){ return (*v).append(3); }).run(*conn), (R::Array{0, 1, 2, 3}));
    TEST_EQ(R::do_(1, 2, [=](R::Var x, R::Var y){ return *x + *y; }).run(*conn), (3));
    TEST_EQ(R::do_([=](){ return R::expr(1); }).run(*conn), (1));
    TEST_EQ(R::do_(1).run(*conn), (1));
    TEST_EQ(R::expr("abc").do_([=](R::Var v){ return (*v).append(3); }).run(*conn), (err("RqlRuntimeError", "Expected type ARRAY but found STRING.", R::Array{1, 0})));
    TEST_EQ(R::expr("abc").do_([=](R::Var v){ return *v + 3; }).run(*conn), (err("RqlRuntimeError", "Expected type STRING but found NUMBER.", R::Array{1, 1})));
    TEST_EQ((R::expr("abc").do_([=](R::Var v){ return *v + "def"; }) + 3).run(*conn), (err("RqlRuntimeError", "Expected type STRING but found NUMBER.", R::Array{1})));
    TEST_EQ(R::expr(5).do_(R::row).run(*conn), (5));
    TEST_EQ(R::branch(true, 1, 2).run(*conn), (1));
    TEST_EQ(R::branch(false, 1, 2).run(*conn), (2));
    TEST_EQ(R::branch(1, "c", false).run(*conn), ("c"));
    TEST_EQ(R::branch(R::Nil(), R::object(), R::array()).run(*conn), (R::Array{}));
    TEST_EQ(R::branch(R::db("test"), 1, 2).run(*conn), (err("RqlRuntimeError", "Expected type DATUM but found DATABASE.", R::Array{})));
    TEST_EQ(R::branch(tbl, 1, 2).run(*conn), (err("RqlRuntimeError", "Expected type DATUM but found TABLE.", R::Array{})));
    TEST_EQ(R::branch(R::error("a"), 1, 2).run(*conn), (err("RqlRuntimeError", "a", R::Array{})));
    TEST_EQ(R::branch(R::array(), 1, 2).run(*conn), (1));
    TEST_EQ(R::branch(R::object(), 1, 2).run(*conn), (1));
    TEST_EQ(R::branch("a", 1, 2).run(*conn), (1));
    TEST_EQ(R::branch(1.2, 1, 2).run(*conn), (1));
    TEST_EQ(R::error("Hello World").run(*conn), (err("RqlRuntimeError", "Hello World", R::Array{0})));
    TEST_EQ(R::error(5).run(*conn), (err("RqlRuntimeError", "Expected type STRING but found NUMBER.", R::Array{0})));
    TEST_EQ(R::js("1 + 1").run(*conn), (2));
    TEST_EQ(R::js("1 + 1; 2 + 2").run(*conn), (4));
    TEST_EQ(R::do_(1, 2, R::js("(function(a, b) { return a + b; })")).run(*conn), (3));
    TEST_EQ(R::expr(1).do_(R::js("(function(x) { return x + 1; })")).run(*conn), (2));
    TEST_EQ(R::expr("foo").do_(R::js("(function(x) { return x + \"bar\"; })")).run(*conn), ("foobar"));
    TEST_EQ(R::js("1 + 2", R::OptArgs{{"timeout", R::expr(1.2)}}).run(*conn), (3));
    TEST_EQ(R::js("(function() { return 1; })").run(*conn), (err("RqlRuntimeError", "Query result must be of type DATUM, GROUPED_DATA, or STREAM (got FUNCTION).", R::Array{0})));
    TEST_EQ(R::js("function() { return 1; }").run(*conn), (err("RqlRuntimeError", "SyntaxError: Unexpected token (", R::Array{0})));
    TEST_EQ(R::do_(1, 2, R::js("(function(a) { return a; })")).run(*conn), (1));
    TEST_EQ(R::do_(1, 2, R::js("(function(a, b, c) { return a; })")).run(*conn), (1));
    TEST_EQ(R::do_(1, 2, R::js("(function(a, b, c) { return c; })")).run(*conn), (err("RqlRuntimeError", "Cannot convert javascript `undefined` to ql::datum_t.", R::Array{0})));
    TEST_EQ(R::expr(R::array(1, 2, 3)).filter(R::js("(function(a) { return a >= 2; })")).run(*conn), (R::Array{2, 3}));
    TEST_EQ(R::expr(R::array(1, 2, 3)).map(R::js("(function(a) { return a + 1; })")).run(*conn), (R::Array{2, 3, 4}));
    TEST_EQ(R::expr(R::array(1, 2, 3)).map(R::js("1")).run(*conn), (err("RqlRuntimeError", "Expected type FUNCTION but found DATUM.", R::Array{0})));
    TEST_EQ(R::expr(R::array(1, 2, 3)).filter(R::js("(function(a) {})")).run(*conn), (err("RqlRuntimeError", "Cannot convert javascript `undefined` to ql::datum_t.", R::Array{0})));
    TEST_EQ(R::expr(R::array(1, 2, 3)).map(1).run(*conn), (err("RqlRuntimeError", "Expected type FUNCTION but found DATUM.", R::Array{0})));
    TEST_EQ(R::expr(R::array(1, 2, 3)).filter("foo").run(*conn), (R::Array{1, 2, 3}));
    TEST_EQ(R::expr(R::array(1, 2, 4)).filter(R::array()).run(*conn), (R::Array{1, 2, 4}));
    TEST_EQ(R::expr(R::array(1, 2, 3)).filter(R::Nil()).run(*conn), (R::Array{}));
    TEST_EQ(R::expr(R::array(1, 2, 4)).filter(false).run(*conn), (R::Array{}));
    TEST_EQ(tbl.count().run(*conn), (0));
    TEST_EQ(R::expr(R::array(1, 2, 3)).for_each([=](R::Var row){ return tbl.insert(R::object("id", *row)); }).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",0.0}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",3}}));
    TEST_EQ(tbl.count().run(*conn), (3));
    TEST_EQ(R::expr(R::array(1, 2, 3)).for_each([=](R::Var row){ return tbl.update(R::object("foo", *row)); }).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",9}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",0.0}}));
    TEST_EQ(R::expr(R::array(1, 2, 3)).for_each([=](R::Var row){ return R::array(tbl.insert(R::object("id", *row)), tbl.insert(R::object("id", *row * 10))); }).run(*conn), (R::Object{{"first_error","Duplicate primary key `id`:\n{\n	\"foo\":	3,\n	\"id\":	1\n}\n{\n	\"id\":	1\n}"}, {"deleted",0.0}, {"replaced",0.0}, {"unchanged",0.0}, {"errors",3}, {"skipped",0.0}, {"inserted",3}}));
    TEST_EQ(tbl.count().run(*conn), (6));
    TEST_EQ(R::expr(R::array(1, 2, 3)).for_each(tbl2.insert(R::object())).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",0.0}, {"generated_keys",arrlen(3, uuid())}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",3}}));
    TEST_EQ(R::expr(R::array(1, 2, 3)).for_each([=](R::Var row){ return R::array(tbl.update(R::object("foo", *row)), tbl.update(R::object("bar", *row))); }).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",36}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",0.0}}));
    TEST_EQ(R::expr(R::array(1, 2, 3)).for_each(tbl2.insert(R::object("id", R::row))).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",0.0}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",3}}));
    TEST_EQ(R::expr(R::array(1, 2, 3)).for_each(1).run(*conn), (err("RqlRuntimeError", "FOR_EACH expects one or more basic write queries.  Expected type ARRAY but found NUMBER.", R::Array{0})));
    TEST_EQ(R::expr(R::array(1, 2, 3)).for_each([=](R::Var x){ return *x; }).run(*conn), (err("RqlRuntimeError", "FOR_EACH expects one or more basic write queries.  Expected type ARRAY but found NUMBER.", R::Array{1, 1})));
    TEST_EQ(R::expr(R::array(1, 2, 3)).for_each(R::row).run(*conn), (err("RqlRuntimeError", "FOR_EACH expects one or more basic write queries.  Expected type ARRAY but found NUMBER.", R::Array{1, 1})));
    TEST_EQ(R::expr(R::array(1, 2, 3)).for_each([=](R::Var row){ return tbl; }).run(*conn), (err("RqlRuntimeError", "FOR_EACH expects one or more basic write queries.", R::Array{1, 1})));
    TEST_EQ(R::expr(1).do_(tbl.insert(R::object("foo", R::row))).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",0.0}, {"generated_keys",arrlen(1, uuid())}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",1}}));
    TEST_EQ(R::expr(R::array(1, 2))[0].do_(tbl.insert(R::object("foo", R::row))).run(*conn), (R::Object{{"deleted",0.0}, {"replaced",0.0}, {"generated_keys",arrlen(1, uuid())}, {"unchanged",0.0}, {"errors",0.0}, {"skipped",0.0}, {"inserted",1}}));
    TEST_EQ(R::expr(R::array(1, 2)).map(tbl.insert(R::object("foo", R::row))).run(*conn), (err("RqlCompileError", "Cannot nest writes or meta ops in stream operations.  Use FOR_EACH instead.", R::Array{0})));
    TEST_EQ(R::expr(R::array(1, 2)).map(R::db("test").table_create("nested_table")).run(*conn), (err("RqlCompileError", "Cannot nest writes or meta ops in stream operations.  Use FOR_EACH instead.", R::Array{0})));
    TEST_EQ(R::expr(1).do_(R::db("test").table_create("nested_table")).run(*conn), (partial(R::Object{{"tables_created",1}})));
    R::db("test").table_drop("nested_table").run(*conn);
    exit_section();
}
