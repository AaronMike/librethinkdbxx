// auto-generated by yaml_to_cxx.py from test/upstream/transform/array.yaml
#include "testlib.h"
void test_upstream_transform_array() {
    enter_section("test_upstream_transform_array: Tests manipulation operations on arrays");
    TEST_DO(auto arr = (R::expr(R::array(1, 2, 3))));
    TEST_DO(auto dupe_arr = (R::expr(R::array(1, 1, 2, 3))));
    TEST_DO(auto objArr = (R::expr(R::array(R::object("a", 1, "b", "a"), R::object("a", 2, "b", "b"), R::object("a", 3, "b", "c")))));
    TEST_DO(auto nestedObjArr = (R::expr(R::array(R::object("a", 1, "b", R::object("c", 1)), R::object("a", 2, "b", R::object("c", 2)), R::object("a", 3, "b", R::object("c", 3))))));
    TEST_EQ(maybe_run(arr.append(4), *conn), (R::Array{1, 2, 3, 4}));
    TEST_EQ(maybe_run(arr.append("a"), *conn), (R::Array{1, 2, 3, "a"}));
    TEST_EQ(maybe_run(arr.prepend(0), *conn), (R::Array{0, 1, 2, 3}));
    TEST_EQ(maybe_run(arr.prepend("a"), *conn), (R::Array{"a", 1, 2, 3}));
    TEST_EQ(maybe_run(arr.difference(R::array(1, 2, 2)), *conn), (R::Array{3}));
    TEST_EQ(maybe_run(arr.difference(R::array()), *conn), (R::Array{1, 2, 3}));
    TEST_EQ(maybe_run(arr.difference(R::array("foo", "bar")), *conn), (R::Array{1, 2, 3}));
    TEST_EQ(maybe_run(dupe_arr.set_insert(1), *conn), (R::Array{1, 2, 3}));
    TEST_EQ(maybe_run(dupe_arr.set_insert(4), *conn), (R::Array{1, 2, 3, 4}));
    TEST_EQ(maybe_run(dupe_arr.set_union(R::array(3, 4, 5, 5)), *conn), (R::Array{1, 2, 3, 4, 5}));
    TEST_EQ(maybe_run(dupe_arr.set_union(R::array(5, 6)), *conn), (R::Array{1, 2, 3, 5, 6}));
    TEST_EQ(maybe_run(dupe_arr.set_intersection(R::array(1, 1, 1, 2, 2)), *conn), (R::Array{1, 2}));
    TEST_EQ(maybe_run(dupe_arr.set_intersection(R::array("foo")), *conn), (R::Array{}));
    TEST_EQ(maybe_run(dupe_arr.set_difference(R::array(1, 1, 1, 10)), *conn), (R::Array{2, 3}));
    TEST_EQ(maybe_run(dupe_arr.set_difference(R::array(2)), *conn), (R::Array{1, 3}));
    TEST_EQ(maybe_run(arr.slice(1, 3), *conn), (R::Array{2, 3}));
    TEST_EQ(maybe_run(arr.slice(1, 3), *conn), (R::Array{2, 3}));
    TEST_EQ(maybe_run(arr.slice(1, 2, R::OptArgs{{"right_bound", R::expr("closed")}}), *conn), (R::Array{2, 3}));
    TEST_EQ(maybe_run(arr.limit(2), *conn), (R::Array{1, 2}));
    TEST_EQ(maybe_run(arr.slice(0, 2), *conn), (R::Array{1, 2}));
    TEST_EQ(maybe_run(arr.slice(1), *conn), (R::Array{2, 3}));
    TEST_EQ(maybe_run(arr.slice(1), *conn), (R::Array{2, 3}));
    TEST_EQ(maybe_run(arr.slice(-2, -1), *conn), (R::Array{2}));
    TEST_EQ(maybe_run(arr.skip(1), *conn), (R::Array{2, 3}));
    TEST_EQ(maybe_run(arr.skip(2), *conn), (R::Array{3}));
    TEST_EQ(maybe_run(arr.skip(12), *conn), (R::Array{}));
    TEST_EQ(maybe_run(arr.limit(2), *conn), (R::Array{1, 2}));
    TEST_EQ(maybe_run(arr.limit(0), *conn), (R::Array{}));
    TEST_EQ(maybe_run(arr.limit(12), *conn), (R::Array{1, 2, 3}));
    TEST_EQ(maybe_run(objArr.pluck("a", "b"), *conn), (R::Array{R::Object{{"a", 1}, {"b", "a"}}, R::Object{{"a", 2}, {"b", "b"}}, R::Object{{"a", 3}, {"b", "c"}}}));
    TEST_EQ(maybe_run(objArr.pluck("a"), *conn), (R::Array{R::Object{{"a", 1}}, R::Object{{"a", 2}}, R::Object{{"a", 3}}}));
    TEST_EQ(maybe_run(objArr.pluck(), *conn), (R::Array{R::Object{}, R::Object{}, R::Object{}}));
    TEST_DO(auto wftst = (objArr.union_(objArr.pluck(std::string("a", 1))).union_(objArr.pluck("b")).union_(R::array(R::object("a", R::Nil())))));
    TEST_EQ(maybe_run(wftst.with_fields("a"), *conn), (R::Array{R::Object{{"a", 1}}, R::Object{{"a", 2}}, R::Object{{"a", 3}}, R::Object{{"a", 1}}, R::Object{{"a", 2}}, R::Object{{"a", 3}}}));
    TEST_EQ(maybe_run(wftst.with_fields("b"), *conn), (R::Array{R::Object{{"b", "a"}}, R::Object{{"b", "b"}}, R::Object{{"b", "c"}}, R::Object{{"b", "a"}}, R::Object{{"b", "b"}}, R::Object{{"b", "c"}}}));
    TEST_EQ(maybe_run(wftst.with_fields("a", "b"), *conn), (R::Array{R::Object{{"a", 1}, {"b", "a"}}, R::Object{{"a", 2}, {"b", "b"}}, R::Object{{"a", 3}, {"b", "c"}}}));
    TEST_EQ(maybe_run(wftst.with_fields(), *conn), (R::Array{R::Object{}, R::Object{}, R::Object{}, R::Object{}, R::Object{}, R::Object{}, R::Object{}, R::Object{}, R::Object{}, R::Object{}}));
    TEST_DO(auto wftst2 = (nestedObjArr.union_(objArr.pluck(R::Object{{"b", std::string("missing", 7)}})).union_(nestedObjArr.pluck(R::object("b", "c")))));
    TEST_EQ(maybe_run(wftst2.with_fields(R::object("b", "c")), *conn), (R::Array{R::Object{{"b", R::Object{{"c", 1}}}}, R::Object{{"b", R::Object{{"c", 2}}}}, R::Object{{"b", R::Object{{"c", 3}}}}, R::Object{{"b", R::Object{{"c", 1}}}}, R::Object{{"b", R::Object{{"c", 2}}}}, R::Object{{"b", R::Object{{"c", 3}}}}}));
    TEST_EQ(maybe_run(wftst.with_fields(1), *conn), (err("ReqlQueryLogicError", "Invalid path argument `1`.", R::Array{})));
    TEST_EQ(maybe_run(R::expr(1).with_fields(), *conn), (err("ReqlQueryLogicError", "Cannot perform has_fields on a non-object non-sequence `1`.", R::Array{})));
    TEST_EQ(maybe_run(objArr.without("a", "b"), *conn), (R::Array{R::Object{}, R::Object{}, R::Object{}}));
    TEST_EQ(maybe_run(objArr.without("a"), *conn), (R::Array{R::Object{{"b", "a"}}, R::Object{{"b", "b"}}, R::Object{{"b", "c"}}}));
    TEST_EQ(maybe_run(objArr.without(), *conn), (R::Array{R::Object{{"a", 1}, {"b", "a"}}, R::Object{{"a", 2}, {"b", "b"}}, R::Object{{"a", 3}, {"b", "c"}}}));
    TEST_EQ(maybe_run(arr.map([=](R::Var v){ return *v + 1; }), *conn), (R::Array{2, 3, 4}));
    TEST_EQ(maybe_run(arr.reduce([=](R::Var a, R::Var b){ return *a + *b; }), *conn), (6));
    TEST_EQ(maybe_run(arr.reduce([=](R::Var a, R::Var b){ return *a + *b; }), *conn), (6));
    TEST_EQ(maybe_run(arr.union_(arr).reduce([=](R::Var a, R::Var b){ return *a + *b; }), *conn), (12));
    TEST_EQ(maybe_run(arr.union_(arr).reduce([=](R::Var a, R::Var b){ return *a + *b; }), *conn), (12));
    TEST_EQ(maybe_run(objArr.filter([=](R::Var row){ return (*row)["b"]=="b"; }), *conn), (R::Array{R::Object{{"a", 2}, {"b", "b"}}}));
    TEST_EQ(maybe_run(arr.concat_map([=](R::Var v){ return R::array(1, 2); }), *conn), (R::Array{1, 2, 1, 2, 1, 2}));
    TEST_EQ(maybe_run(arr.concat_map([=](R::Var v){ return R::array(R::object("v", *v), R::object("v2", *v + 1)); }), *conn), (R::Array{R::Object{{"v", 1}}, R::Object{{"v2", 2}}, R::Object{{"v", 2}}, R::Object{{"v2", 3}}, R::Object{{"v", 3}}, R::Object{{"v2", 4}}}));
    TEST_EQ(maybe_run(objArr.order_by("b"), *conn), (R::Array{R::Object{{"a", 1}, {"b", "a"}}, R::Object{{"a", 2}, {"b", "b"}}, R::Object{{"a", 3}, {"b", "c"}}}));
    TEST_EQ(maybe_run(objArr.order_by(R::desc("b")), *conn), (R::Array{R::Object{{"a", 3}, {"b", "c"}}, R::Object{{"a", 2}, {"b", "b"}}, R::Object{{"a", 1}, {"b", "a"}}}));
    TEST_EQ(maybe_run(R::expr(R::array(R::object("-a", 1), R::object("-a", 2))).order_by("-a"), *conn), (R::Array{R::Object{{"-a", 1}}, R::Object{{"-a", 2}}}));
    TEST_EQ(maybe_run(R::expr(R::array(1, 1, 2, 2, 2, 3, 4)).distinct(), *conn), (R::Array{1, 2, 3, 4}));
    TEST_EQ(maybe_run(objArr.count(), *conn), (3));
    TEST_EQ(maybe_run(arr.union_(objArr), *conn), (R::Array{1, 2, 3, R::Object{{"a", 1}, {"b", "a"}}, R::Object{{"a", 2}, {"b", "b"}}, R::Object{{"a", 3}, {"b", "c"}}}));
    TEST_EQ(maybe_run(arr[1], *conn), (2));
    TEST_EQ(maybe_run(arr.nth(1), *conn), (2));
    TEST_EQ(maybe_run(arr[0], *conn), (1));
    TEST_EQ(maybe_run(R::expr(R::array()).is_empty(), *conn), (true));
    TEST_EQ(maybe_run(arr.is_empty(), *conn), (false));
    TEST_EQ(maybe_run(arr.contains(2), *conn), (true));
    TEST_EQ(maybe_run(arr.contains(2, 3), *conn), (true));
    TEST_EQ(maybe_run(arr.contains(4), *conn), (false));
    TEST_EQ(maybe_run(arr.contains(2, 4), *conn), (false));
    TEST_EQ(maybe_run(arr.contains(2, 2), *conn), (false));
    TEST_EQ(maybe_run(arr.union_(arr).contains(2, 2), *conn), (true));
    TEST_EQ(maybe_run(arr.contains([=](R::Var x){ return *x==2; }), *conn), (true));
    TEST_EQ(maybe_run(arr.contains([=](R::Var x){ return *x==2; }, [=](R::Var x){ return *x==3; }), *conn), (true));
    TEST_EQ(maybe_run(arr.contains([=](R::Var x){ return *x==4; }), *conn), (false));
    TEST_EQ(maybe_run(arr.contains([=](R::Var x){ return *x==2; }, [=](R::Var x){ return *x==4; }), *conn), (false));
    TEST_EQ(maybe_run(arr.contains([=](R::Var x){ return *x==2; }, [=](R::Var x){ return *x==2; }), *conn), (false));
    TEST_EQ(maybe_run(arr.union_(arr).contains([=](R::Var x){ return *x==2; }, [=](R::Var x){ return *x==2; }), *conn), (true));
    TEST_EQ(maybe_run(R::expr(R::array(R::object("a", 1), R::object("b", 2), R::object("a", 3, "c", 4)))["a"], *conn), (R::Array{1, 3}));
    TEST_EQ(maybe_run(R::expr(R::array(R::object("a", 1), "a", R::object("b", 2), R::object("a", 3, "c", 4)))["a"], *conn), (err("ReqlQueryLogicError", "Cannot perform bracket on a non-object non-sequence `\"a\"`.", R::Array{})));
    exit_section();
}
