// auto-generated by yaml_to_cxx.py from test/upstream/transform/fold.yaml
#include "testlib.h"
void test_upstream_transform_fold() {
    enter_section("test_upstream_transform_fold: Tests for the fold term");
    temp_table tbl_table;
    R::Query tbl = tbl_table.table();
    TEST_EQ(maybe_run(tbl.insert(R::range(100).map([=](R::Var i){ return R::object("id", *i, "a", *i % 4); }).coerce_to("array")), *conn), (R::Object{{"deleted", 0}, {"replaced", 0}, {"unchanged", 0}, {"errors", 0}, {"skipped", 0}, {"inserted", 100}}));
    TEST_EQ(maybe_run(R::range(0, 10).fold(0, [=](R::Var acc, R::Var row){ return (*acc).add(1); }), *conn), (10));
    TEST_EQ(maybe_run(R::range(0, 10).fold(0, [=](R::Var acc, R::Var row){ return (*acc).add(1); }, R::OptArgs{{"final_emit", R::expr([=](R::Var acc){ return (*acc).mul(2); })}}), *conn), (20));
    TEST_EQ(maybe_run(R::range(0, 10).fold(0, [=](R::Var acc, R::Var row){ return (*acc).add(1); }, R::OptArgs{{"emit", R::expr([=](R::Var old, R::Var row, R::Var acc){ return R::array(*row); })}}).coerce_to("array"), *conn), (R::Array{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}));
    TEST_EQ(maybe_run(R::range(0, 10).fold(0, [=](R::Var acc, R::Var row){ return (*acc).add(1); }, R::OptArgs{{"emit", R::expr([=](R::Var old, R::Var row, R::Var acc){ return R::branch((*acc).mod(3).eq(0), R::array(*row), R::array()); })}, {"final_emit", R::expr([=](R::Var acc){ return R::array(*acc); })}}).coerce_to("array"), *conn), (R::Array{2, 5, 8, 10}));
    TEST_EQ(maybe_run(R::range(0, 10).fold(R::array(1, 1), [=](R::Var acc, R::Var row){ return R::array((*acc)[1], (*acc)[0].add((*acc)[1])); }, R::OptArgs{{"emit", R::expr([=](R::Var old, R::Var row, R::Var acc){ return R::array((*acc)[0]); })}}).coerce_to("array"), *conn), (R::Array{1, 2, 3, 5, 8, 13, 21, 34, 55, 89}));
    TEST_EQ(maybe_run(R::range(0, 10).fold(0, [=](R::Var acc, R::Var row){ return *acc; }, R::OptArgs{{"emit", R::expr([=](R::Var old, R::Var row, R::Var acc){ return *acc; })}}).type_of(), *conn), ("STREAM"));
    TEST_EQ(maybe_run(tbl.filter("id").fold(0, [=](R::Var acc, R::Var row){ return (*acc).add(1); }, R::OptArgs{{"emit", R::expr([=](R::Var old, R::Var row, R::Var acc){ return R::branch((*old).mod(20).eq(0), R::array(*row), R::array()); })}}).coerce_to("array"), *conn), (R::Array{R::Object{{"a", 0}, {"id", 20}}, R::Object{{"a", 3}, {"id", 15}}, R::Object{{"a", 2}, {"id", 46}}, R::Object{{"a", 2}, {"id", 78}}, R::Object{{"a", 2}, {"id", 90}}}));
    TEST_EQ(maybe_run(R::range().fold(0, [=](R::Var acc, R::Var row){ return (*acc).add(1); }, R::OptArgs{{"emit", R::expr([=](R::Var old, R::Var row, R::Var acc){ return R::array(*acc); })}}).limit(10), *conn), (R::Array{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));
    TEST_EQ(maybe_run(R::range().fold(0, [=](R::Var acc, R::Var row){ return (*acc).add(1); }, R::OptArgs{{"emit", R::expr([=](R::Var old, R::Var row, R::Var acc){ return R::array(*acc); })}}).map([=](R::Var doc){ return R::expr(1); }).reduce([=](R::Var l, R::Var r){ return *l + *r; }), *conn), (err("ReqlQueryLogicError", "Cannot use an infinite stream with an aggregation function (`reduce`, `count`, etc.) or coerce it to an array.")));
    TEST_EQ(maybe_run(R::range(0, 1000).fold(0, [=](R::Var acc, R::Var row){ return (*acc).add(1); }, R::OptArgs{{"emit", R::expr([=](R::Var old, R::Var row, R::Var acc){ return R::array(*acc); })}}).coerce_to("array"), *conn), (R::range(1, 1001).map([=](R::Var x){ return *x; })));
    exit_section();
}
