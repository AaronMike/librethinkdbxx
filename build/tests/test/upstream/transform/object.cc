// auto-generated by yaml_to_cxx.py from test/upstream/transform/object.yaml
#include "testlib.h"
void test_upstream_transform_object() {
    enter_section("test_upstream_transform_object: Tests manipulation operations on objects");
    TEST_DO(auto obj = (R::expr(R::object("a", 1, "b", 2, "c", "str", "d", R::Nil(), "e", R::object("f", "buzz")))));
    TEST_EQ(obj["a"].run(*conn), (1));
    TEST_EQ(obj["c"].run(*conn), ("str"));
    TEST_EQ(obj.has_fields("b").run(*conn), (true));
    TEST_EQ(obj.keys().contains("d").run(*conn), (true));
    TEST_EQ(obj.has_fields("d").run(*conn), (false));
    TEST_EQ(obj.has_fields(R::object("e", "f")).run(*conn), (true));
    TEST_EQ(obj.has_fields(R::object("e", "g")).run(*conn), (false));
    TEST_EQ(obj.has_fields("f").run(*conn), (false));
    TEST_EQ(obj.has_fields("a", "b").run(*conn), (true));
    TEST_EQ(obj.has_fields("a", "d").run(*conn), (false));
    TEST_EQ(obj.has_fields("a", "f").run(*conn), (false));
    TEST_EQ(obj.has_fields("a", R::object("e", "f")).run(*conn), (true));
    TEST_EQ(R::expr(R::array(obj, obj.pluck("a", "b"))).has_fields("a", "b").count().run(*conn), (2));
    TEST_EQ(R::expr(R::array(obj, obj.pluck("a", "b"))).has_fields("a", "c").count().run(*conn), (1));
    TEST_EQ(R::expr(R::array(obj, obj.pluck("a", "e"))).has_fields("a", R::object("e", "f")).count().run(*conn), (2));
    TEST_EQ(obj.pluck("a").run(*conn), (R::Object{{"a",1}}));
    TEST_EQ(obj.pluck("a", "b").run(*conn), (R::Object{{"a",1}, {"b",2}}));
    TEST_EQ(obj.without("a").run(*conn), (R::Object{{"b",2}, {"c","str"}, {"d",R::Nil()}, {"e",R::Object{{"f","buzz"}}}}));
    TEST_EQ(obj.without("a", "b").run(*conn), (R::Object{{"c","str"}, {"d",R::Nil()}, {"e",R::Object{{"f","buzz"}}}}));
    TEST_EQ(obj.without("a", "b", "c", "d").run(*conn), (R::Object{{"e",R::Object{{"f","buzz"}}}}));
    TEST_EQ(obj.without(R::object("e", "f")).run(*conn), (R::Object{{"a",1}, {"b",2}, {"c","str"}, {"d",R::Nil()}, {"e",R::Object{}}}));
    TEST_EQ(obj.without(R::object("e", "buzz")).run(*conn), (R::Object{{"a",1}, {"b",2}, {"c","str"}, {"d",R::Nil()}, {"e",R::Object{{"f","buzz"}}}}));
    TEST_EQ(obj.merge(1).run(*conn), (1));
    TEST_EQ(obj.merge(R::object("e", -2)).run(*conn), (R::Object{{"a",1}, {"b",2}, {"c","str"}, {"d",R::Nil()}, {"e",-2}}));
    TEST_EQ(obj.merge(R::object("e", R::literal())).run(*conn), (R::Object{{"a",1}, {"b",2}, {"c","str"}, {"d",R::Nil()}}));
    TEST_EQ(obj.merge(R::object("e", R::object("f", "quux"))).run(*conn), (R::Object{{"a",1}, {"b",2}, {"c","str"}, {"d",R::Nil()}, {"e",R::Object{{"f","quux"}}}}));
    TEST_EQ(obj.merge(R::object("e", R::object("g", "quux"))).run(*conn), (R::Object{{"a",1}, {"b",2}, {"c","str"}, {"d",R::Nil()}, {"e",R::Object{{"f","buzz"}, {"g","quux"}}}}));
    TEST_EQ(obj.merge(R::object("e", R::literal(R::object("g", "quux")))).run(*conn), (R::Object{{"a",1}, {"b",2}, {"c","str"}, {"d",R::Nil()}, {"e",R::Object{{"g","quux"}}}}));
    TEST_EQ(obj.merge(R::object("a", -1)).run(*conn), (R::Object{{"a",-1}, {"b",2}, {"c","str"}, {"d",R::Nil()}, {"e",R::Object{{"f","buzz"}}}}));
    TEST_DO(auto errmsg = ("Stray literal keyword found: literal is only legal inside of the object passed to merge or update and cannot nest inside other literals."));
    TEST_EQ(R::literal("foo").run(*conn), (err("RqlRuntimeError", errmsg, R::Array{})));
    TEST_EQ(obj.merge(R::literal("foo")).run(*conn), (err("RqlRuntimeError", errmsg, R::Array{})));
    TEST_EQ(obj.merge(R::object("foo", R::literal(R::literal("foo")))).run(*conn), (err("RqlRuntimeError", errmsg, R::Array{})));
    TEST_DO(auto o = (R::expr(R::object("a", R::object("b", 1, "c", 2), "d", 3))));
    TEST_EQ(o.merge(R::object("e", 4), R::object("f", 5)).run(*conn), (R::Object{{"a",R::Object{{"b",1}, {"c",2}}}, {"d",3}, {"e",4}, {"f",5}}));
    TEST_EQ(R::expr(R::array(o, o.merge(R::object("d", 4)))).merge([=](R::Var row){ return R::object("e", (*row)["d"]); }).run(*conn), (R::Array{R::Object{{"a",R::Object{{"b",1}, {"c",2}}}, {"d",3}, {"e",3}}, R::Object{{"a",R::Object{{"b",1}, {"c",2}}}, {"d",4}, {"e",4}}}));
    TEST_EQ(R::expr(R::array(o, o.merge(R::object("d", 4)))).merge(R::object("e", R::row["d"])).run(*conn), (R::Array{R::Object{{"a",R::Object{{"b",1}, {"c",2}}}, {"d",3}, {"e",3}}, R::Object{{"a",R::Object{{"b",1}, {"c",2}}}, {"d",4}, {"e",4}}}));
    TEST_EQ(R::expr(R::array(o, o.merge(R::object("d", 4)))).merge([=](R::Var row){ return R::object("a", R::object("b", 2)); }).run(*conn), (R::Array{R::Object{{"a",R::Object{{"b",2}, {"c",2}}}, {"d",3}}, R::Object{{"a",R::Object{{"b",2}, {"c",2}}}, {"d",4}}}));
    TEST_EQ(R::expr(R::array(o, o.merge(R::object("d", 4)))).merge([=](R::Var row){ return R::object("a", R::literal(R::object("b", 2))); }).run(*conn), (R::Array{R::Object{{"a",R::Object{{"b",2}}}, {"d",3}}, R::Object{{"a",R::Object{{"b",2}}}, {"d",4}}}));
    TEST_EQ(obj.keys().run(*conn), (R::Array{"a", "b", "c", "d", "e"}));
    exit_section();
}
